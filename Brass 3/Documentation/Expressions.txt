The expression parser operates on labels. Labels can either be named variables or literals.

	Brass: = 12

"12" is a literal, "Brass" is a named variable. Literals are string constants ("") or anything that can be directly interpreted as a number.

Labels have two major numeric fields: a value and a page number. By default, only the value is accessed. If you put a colon in front of the label you can access its page field. Putting a colon after the label name accesses its normal value field. If no colon is specified then the label's value is accessed implicitly.

	X: = 12 ; Assign 12 to X's value field (explicit).
	:X = 34 ; Assign 34 to X's page field (explicit).
	X  = 56 ; Assign 56 to X's value field (implicit).

When a label is created it is cloned from the current program counter (which itself is stored in the named label '$'). For example:

	$: = 12
	:$ = 34

	X ; Automatically has the value 12 and page 34.

Assignments only work on named labels. A potential area of confusion is that assigments transfer a single value. Thus:

	:$ = 1
	X
	:$ = 2
	Y = X
	:$ = 3
	Z = Y

	.echoln :X, ' ', :Y, ' ', :Z

This displays "1 2 3" rather than "1 1 1" as only the value is copied each time. To copy both fields across you would need to do this:

	:$ = 1
	X
	:$ = 2
	Y: = X: \ :Y = :X
	:$ = 3
	Z: = Y: \ :Z = :Y

	.echoln :X, ' ', :Y, ' ', :Z

There are two "magic" variable names: $ (program counter) and @ (output counter). $ and @ can have different values. The convention is that @ represents where in the object file data appears, and $ represents the target CPU's program counter value. This way you can have a block of code output at one address, but addresses referenced by that code (eg for calls and jumps) will appear as if the code is in another location entirely.

The program counter and output counter are incremented by one for each byte of output data written. This is always the case, even if an output modifier plugin is loaded that changes the size of each byte written!

Expressions can make use of the following operators (shown in order of precedence):

Unary          +, -, !, ~, ++x, --x
Power          **
Multiplicative *, /, %
Additive       +, -
Shift          <<, >>
Relational     <, >, <=, >=
Equality       ==, !=
Logical        &
               ^
               |
Conditional    &&
               ||
Assignment     =, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=
 
The higher up the table the higher the precedence of the operator. If two operator are in the same line (eg * and /) they are normally evaluated from left->right order.
The assigment operators are evaluated from right->left, however.

	a * b / c ; (a*b)/c
	a = b = c ; a=(b=c)

[Tip: Run Brass with no command-line parameters to use it as a calculator].