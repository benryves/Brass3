#define TI83P

; ==================================================================================================
; Headers
; ==================================================================================================

#define equ .equ
#define EQU .equ
#define END .end

#include "keyval.inc"

; ==================================================================================================
; TI-83 Plus Ion
; ==================================================================================================

#ifdef TI83P
#define	bcall(label)	RST 28h \ .dw label
.org 9D93h
.db $BB,$6D
	ret
	jr nc,Init_All
#include "ti83plus.inc"
#include "ion8X.inc"
#endif

; ==================================================================================================
; TI-83 Plus MirageOS
; ==================================================================================================

#ifdef TI83M
#define	bcall(label)	RST 28h \ .dw label
.org 9D93h
.db $BB,$6D
	ret
.db 1
.db $00,$00,$00,$00,$7F,$FC,$50,$00,$57,$DC,$50,$50,$57,$58,$55,$50
.db $57,$5C,$55,$40,$55,$7C,$00,$00,$7F,$FC,$00,$00,$00,$00
#include "ti83plus.inc"
#include "mirage.inc"
#endif

; ==================================================================================================
; Variables:
; ==================================================================================================

#define standardView 48
#define mem appBackUpScreen
#define playerX    mem+00
#define playerY    mem+01
#define playerF    mem+02
#define keyPress   mem+03
#define lookScroll mem+04
#define vScale     mem+05
#define mapLoc     mem+06 ; Where are we on the map? (in RAM)
#define mapLocL    mem+08 ; 
#define mapLocR    mem+10 ;
#define mapOff     mem+12 ; What offset do we add each step?
#define wallPosN   mem+14 ; What position is this slice of wall?
#define wallPosO   mem+15 ; Position of the last wall slice
#define map        mem+16

.db "Maze Demo - Ben Ryves",0

Init_All:

createNewMap:
	bcall(_grBufClr)
	ld hl,map
	ld bc,256
	ld a,1
	bcall(_memSet)


	ld hl,map+17

	ld d,13
clearMiddleMap:
	push de
	ld bc,13
	xor a
	bcall(_memSet)
	ld de,4
	add hl,de
	pop de
	dec d
	ld a,d
	or a
	jr nz,clearMiddleMap


	ld hl,2+(256*2)
	ld (playerX),hl

fillMoreBlobs:
	call convertXYToMap

	ld (mapLoc),hl

	ld a,1
	ld (hl),a


	

	ld a,3
	ld (playerF),a

	ld b,4
	call ionRandom
	ld (keyPress),a

tryFillingAgain:
	call getDirVector

	ld hl,(mapLoc)

	add hl,de

	ld a,(hl)

	or a
	jr z,canFillEmpty

	
	ld a,(playerF)
	dec a
	ld (playerF),a
	or a
	jr z,canFillEmpty

	ld a,(keyPress)
	inc a
	jr tryFillingAgain


canFillEmpty:

	ld a,1
	ld (hl),a

	ld a,(playerX)
	add a,2
	ld (playerX),a
	cp 16
	jr nz,fillMoreBlobs

	ld a,2
	ld (playerX),a

	ld a,(playerY)
	add a,2
	ld (playerY),a
	cp 16
	jr z,doneRandomMap
notNextLineBlobs:
	jr fillMoreBlobs

doneRandomMap:

	ld hl,map
	ld bc,17+(256*17)

drawMapLoop:
	ld a,(hl)
	or a

	jr z,isEmptyMap

	push hl
	push bc

	ld a,b
	ld l,c
	ld ix,mapBlock
	ld b,2
	call ionPutSprite

	pop bc
	pop hl

isEmptyMap:

	inc b
	inc b
	ld a,b
	cp 17+30
	jr nz,notNextLine
	ld b,17
	inc c
	inc c
	inc hl
	ld a,c
	cp 17+30
	jr z,drawnMapOnTitle
notNextLine:

	inc hl


	jr drawMapLoop

drawnMapOnTitle:


	call lastDraw
	call ionFastCopy




	bcall(_getCSC)
	cp skClear
	ret z
	cp sk2nd
	jp nz,createNewMap



	ld hl,7+(256*7)
	ld (playerX),hl

	ld a,standardView
	ld (vScale),a
	xor a
	ld (lookScroll),a

drawLoop:
	; Clear the screen
	bcall(_grBufClr)

	; Get player position, convert to a location on the map. 

	call convertXYToMap
	push hl
	ld a,(playerF)
	add a,2
	call getDirVector
	pop hl
	add hl,de
	ld (mapLoc),hl

	; Find out where our probing ray goes each step.
	ld a,(playerF)
	call getDirVector
	ld (mapOff),de

	ld a,(playerF)
	dec a
	call getDirVector
	ld hl,(mapLoc)
	add hl,de
	ld (mapLocL),hl
	

	ld a,(playerF)
	inc a
	call getDirVector
	ld hl,(mapLoc)
	add hl,de
	ld (mapLocR),hl

	ld a,(vScale)
	ld (wallPosN),a
	ld (wallPosO),a

castLoop:
	
	ld hl,(mapLoc)
	ld de,(mapOff)
	add hl,de
	ld a,(hl)
	or a ; If it's a zero, then we'll loop again.
	jr z,castNotHitEndWall

	; We have hit the end wall. Draw the horizontal span!

	ld a,(wallPosN)
	ld b,a
	add a,31
	ld e,a
	ld a,32
	sub b
	ld c,a
	ld a,e
	inc a
	sub c
	jr z,noDrawSpan
	ld b,a
	ld a,c	

	call drawHorizSpan

noDrawSpan:


	

castNotHitEndWall:

	; Take a peer on the RIGHT
	ld a,(wallPosN)
	ld c,a
	ld a,(wallPosO)
	sub c
	jr z,drawnRight
	ld b,a
	ld a,(wallPosN)
	add a,32
	ld e,a
	dec e
	push de
	push bc
	push af
	ld hl,(mapLocR)
	ld a,(hl)
	or a
	jr nz,drawRightDiags
	pop af
	pop bc
	pop de
	call drawHorizSpan
	jr drawnRight
drawRightDiags:
	pop af
	pop bc
	pop de
	ld c,1
	call drawDiag
drawnRight:


	; Take a peer on the LEFT
	ld a,(wallPosN)
	ld c,a
	ld a,(wallPosO)
	sub c
	jr z,drawnLeft
	ld b,a
	ld a,(wallPosN)
	add a,31
	ld e,a
	ld a,(wallPosN)
	ld c,a
	ld a,32
	sub c
	push de
	push bc
	push af
	ld hl,(mapLocL)
	ld a,(hl)
	or a
	jr nz,drawLeftDiags
	pop af
	pop bc
	pop de
	sub b
	call drawHorizSpan
	jr drawnLeft
drawLeftDiags:
	pop af
	pop bc
	pop de
	ld c,-1
	call drawDiag
drawnLeft:

	; Draw the vertical wall markings
	ld a,(wallPosN)
	push af
	push af
	add a,31
	ld e,a
	pop af
	ld b,a
	ld a,32
	sub b
	
	call ionGetPixel

	pop bc	
	call drawVerticalBar
	
	ld a,(wallPosN)
	push af
	add a,32
	ld e,a
	dec e

	call ionGetPixel

	pop bc
	call drawVerticalBar
	

	ld a,(wallPosN)
	ld (wallPosO),a
	srl a
	jr z,castEnded
	ld (wallPosN),a

	ld de,(mapOff)
	ld hl,(mapLoc)
	add hl,de
	ld a,(hl)
	or a
	jr nz,castEnded

	ld (mapLoc),hl

	ld hl,(mapLocL)
	add hl,de
	ld (mapLocL),hl

	ld hl,(mapLocR)
	add hl,de
	ld (mapLocR),hl

	jp castLoop

castEnded:

	; Mirror!

	ld hl,plotsScreen
	ld de,plotsScreen+(12*63)
	ld c,32

flipCopyLoop:
	ld b,12
flipCopyLine:
	ld a,(de)
	ld (hl),a
	inc hl
	inc de
	djnz flipCopyLine

	push hl
	ld hl,-24
	add hl,de
	ex de,hl
	pop hl

	dec c
	jr nz,flipCopyLoop


	; If we're moving around...

	ld a,(vScale)
	cp standardView
	jr z,notVScale
	jr c,isSmaller
	sub 4
	jr setNewVScale
isSmaller:
	add a,2
setNewVScale:
	ld (vScale),a

	call lastDraw
	call ionFastCopy
	jp drawLoop

notVScale:
	ld a,(lookScroll)
	or a
	jp z,noShifts

	ld b,a
	and %10000000
	jr z,spinIsPositive


	
	ld a,(lookScroll)
	neg
	ld (lookScroll),a
	ld hl,plotsScreen+767
	ld e,a
	ld d,0
	xor a
	sbc hl,de
	ld de,plotsScreen+767
	ld bc,768
	lddr


	ld a,(lookScroll)


	ld b,a
	ld a,8
	sub b
	ld hl,savesScreen
	ld d,0
	ld e,a
	add hl,de
	ld de,plotsScreen
	call copyFromOld
	ld a,(lookScroll)
	neg
	ld (lookScroll),a

	ld hl,lookScroll
	inc (hl)

	jr setNewSpin


spinIsPositive:

	ld hl,plotsScreen
	ld a,(lookScroll)
	ld e,a
	ld d,0
	add hl,de
	ld de,plotsScreen
	ld bc,768
	ldir

	ld hl,plotsScreen
	ld a,(lookScroll)
	ld b,a
	ld a,8
	sub b
	ld e,a
	ld d,0
	add hl,de
	ld de,savesScreen
	ex de,hl
	call copyFromOld
	ld hl,lookScroll
	dec (hl)

setNewSpin:

	call lastDraw
	call ionFastCopy

	jp drawLoop	


noShifts:
	call lastDraw
	call ionFastCopy

gameKeyLoop:

	ld a,KeyRow_5
	out (1),a
	in a,(1)
	cp dkClear
	jp nz,gkNotClear

waitClearReleased:
	ei
	halt
	ld a,KeyRow_5
	out (1),a
	in a,(1)
	cp dkClear
	jr z,waitClearReleased
	jp createNewMap


gkNotClear:

	ld a,KeyRow_Pad
	out (1),a
	in a,(1)
	cp $FF
	jr z,gameKeyLoop
	ld (keyPress),a

	ld a,(keyPress)
	bit 1,a
	jr nz,gkNotLeft
	ld a,(playerF)
	dec a
	and %00000011
	ld (playerF),a
	call backupScreen
	ld a,7
	ld (lookScroll),a
	jp drawLoop
gkNotLeft:

	ld a,(keyPress)
	bit 2,a
	jr nz,gkNotRight
	ld a,(playerF)
	inc a
	and %00000011
	ld (playerF),a
	call backupScreen
	ld a,-7
	ld (lookScroll),a
	jp drawLoop
gkNotRight:

	ld a,(keyPress)
	bit 3,a
	jr nz,gkNotUp
	call convertXYToMap
	push hl
	ld a,(playerF)
	call getDirVector
	pop hl
	add hl,de
	ld a,(hl)
	or a
	jp nz,drawLoop
	call convertMapToXY

	ld a,standardView/2
	ld (vScale),a

	jp drawLoop
gkNotUp:
	
	ld a,(keyPress)
	bit 0,a
	jr nz,gkNotDown
	call convertXYToMap
	push hl
	ld a,(playerF)
	add a,2
	call getDirVector
	pop hl
	add hl,de
	ld a,(hl)
	or a
	jp nz,drawLoop
	call convertMapToXY

	ld a,standardView*2
	ld (vScale),a

	jp drawLoop
gkNotDown:

	jp drawLoop

	ret

; ROUTINES:

copyFromOld:
	ld b,64
spCopyOld:
	push bc
	push hl
	push de	
	ld a,(lookScroll)
	ld c,a
	ld b,0
	ldir
	pop de
	ld hl,12
	add hl,de
	pop de
	push hl
	ld hl,12
	add hl,de
	pop de
	pop bc
	djnz spCopyOld
	ret

; Draws a bar from location (hl), bitmask 'a', 'b' high (BACKWARDS - so draws upwards).
drawVerticalBar:
	ld c,a
	ld a,b
	cp 33
	ret nc
	ld de,-12	
drawVerticalBarLoop:
	ld a,c
	or (hl)
	ld (hl),a
	add hl,de
	djnz drawVerticalBarLoop
	ret

backupScreen:
	ld hl,plotsScreen+2
	ld de,savesScreen
	ld bc,768
	ldir
	ret



; Converts a position on the map into (x,y)

convertMapToXY:
	ld de,map
	xor a
	sbc hl,de
	ld a,l
	and %00001111
	ld (playerX),a
	ld a,l
	sra a
	sra a
	sra a
	sra a
	and %00001111
	ld (playerY),a
	ret

convertXYToMap:
	ld a,(playerY)
	add a,a
	add a,a
	add a,a
	add a,a
	ld b,a
	ld a,(playerX)
	add a,b
	ld l,a
	ld h,0
	ld de,map
	add hl,de
	ret


lastDraw:
	ld hl,plotsScreen+8
	ld c,64
	ld de,8
lastDrawBlankLineLoop:
	ld b,4	
lastDrawBlankLoop:
	ld a,$FF
	ld (hl),a
	inc hl
	djnz lastDrawBlankLoop
	add hl,de
	dec c
	ld a,c
	or a
	jr nz,lastDrawBlankLineLoop

	ld hl,plotsScreen+765
	ld de,plotsScreen+767
	ld bc,768
	lddr

	ld hl,$FFFF
	ld (plotsScreen),hl

	ret

drawHorizSpan:	;Draws a line from (a,e) to (a+b,e)

	ld c,a
	
	ld a,e
	cp 65
	ret nc

	ld a,c	
drawHorizSpanLoop:
	push bc
	inc a
	ld d,a
	push de
	cp 65
	jr nc,dhsSkipPixel
	call ionGetPixel
	or (hl)
	ld (hl),a
dhsSkipPixel:
	pop de
	ld a,d
	pop bc
	djnz drawHorizSpanLoop
	ret

drawDiag:
	ld d,a
	ld a,e
	cp 65
	ret nc
	ld a,d
drawDiagLoop:
	push bc
	add a,c
	inc e
	ld d,a
	push de
	cp 65
	jr nc,ddSkipPixel
	call ionGetPixel
	or (hl)
	ld (hl),a
ddSkipPixel:
	pop de
	ld a,d
	pop bc
	djnz drawDiagLoop
	ret

getDirVector:	;For a direction 'a', calculate a "unit vector" (map offset val) and return in de

	and %00000011
	ld l,a
	ld h,0
	ld de,facingTable
	add hl,de
	ld a,(hl)
	ld l,a
	ld h,0
	ld e,a
	ld d,0
	and %11110000
	cp %11110000
	ret nz
	ld d,$FF
	ret

mapBlock: .db %11000000, %11000000
facingTable: .db -16,1,16,-1

.end
END

