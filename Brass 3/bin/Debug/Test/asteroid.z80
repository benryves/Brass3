#define TI83P
;.variablename "ASTEROID"
;.binarytype TI8x
;.tivariabletype 5
;			Asteroids v.0.98
;	  Written by Joe Pemberton (darksk8er@buffbody.com)
;			AIM: zero sicness
;
;	Thanks to Jason Kovacs for his rectangle/line drawing routines.
;
;	Visit 'http://tiworld.calc.org' for more calculator games.
;

.nolist

;Uncomment these things before compilation for debugging etc.
;
;#define INVINCIBLE
;#define DEBUGTIMER
;#define SHOWLEVELTIMER
;#define THREE_ENEMIES
;#define DEBUGMODE

#define equ .EQU
#define EQU .EQU
#define end .END
#define END .END

#include "ion.inc"
#include "keys.inc"

fontFlags	EQU  50
fracDrawLFont	EQU    2


DefaultXSpriteHeight	equ	8

maxshots	equ	16
maxasteroids	equ	45
moneyrate	equ	6		;1/6 asteroids makes a money
healthrate	equ	12		;1/12 asteroids makes a health
moneyTTL	equ	700		;money/health lasts for 700 frames
shotTTL		equ	33		;shots last 33 frames
leveltimerRATE	equ	20		;20 frames between each game "second"
regenrate	equ	25		;25 frames between each regen
regenduration	equ	100		;heals 100 before it runs out
deathbuf	equ	4		;must have 4 pixels buffer around ship to reappear after death

retrospeed1	equ	5
retrospeed2	equ	12

shottable		equ	saferam1 ;TTL, xcoord(2), ycoord(2), xspeed(2), yspeed(2)
asteroidtable		equ	shottable+(9*maxshots)	;alive, type, xcoord(2), ycoord(2), xspeed(2), yspeed(2), ttl(2)
shottemptable		equ	asteroidtable+(maxasteroids*12)
shiptemptable		equ	shottemptable+(maxshots*4)+1


Aalive			equ	0
Atype			equ	1
AxMSB			equ	3
AyMSB			equ	5
mTTLMSB			equ	11
mTTLLSB			equ	10

#ifdef TI83P
interrupt_table		equ	$8700		;savesscreen
interrupt_table_byte	equ	$87
interrupt_vector	equ	$8888
interrupt_vector_byte	equ	$88
#else
interrupt_table		equ	$8600		;statvars
interrupt_table_byte	equ	$86
interrupt_vector	equ	$8787
interrupt_vector_byte	equ	$87
#endif



screen_as_buffer	equ	12



#ifdef TI83P
begin_var	equ	$8888+20	;right after the interrupt vector in savesscreen
#else
begin_var	equ	$858f		;beginning of statvars
#endif

angle		equ	begin_var
velocity_y	equ	angle+1
velocity_x	equ	velocity_y+2
ypos		equ	velocity_x+2
xpos		equ	ypos+2
shotflag	equ	xpos+2
alphaflag	equ	shotflag+1
randPOS		equ	alphaflag+1
timecounter	equ	randPOS+1
timecounterflag	equ	timecounter+1
health		equ	timecounterflag+1
hurttimer	equ	health+1
deathflag	equ	hurttimer+1
explosioncnt	equ	deathflag+1
level		equ	explosioncnt+1
numasteroids	equ	level+1
EOLcounter	equ	numasteroids+1	;end of level counter
money		equ	EOLcounter+1	
leveltimerLSB	equ	money+2
leveltimer	equ	leveltimerLSB+1
score		equ	leveltimer+2
lives		equ	score+2
temp		equ	lives+1
;UPGRADES
retrospeed	equ	temp+2
armor		equ	retrospeed+2
engine		equ	armor+1
retro		equ	engine+1
rapidfire	equ	retro+1
rapidfiretimer	equ	rapidfire+1
regen		equ	rapidfiretimer+1
regenflag	equ	regen+1
regentotal	equ	regenflag+1
doubleshot	equ	regentotal+1
doubleEnable	equ	doubleshot+1
maxbullets	equ	doubleEnable+1

end_var:	equ	maxbullets+1

.list
#ifdef TI83P
.org	ProgStart-2
	.db	$BB,$6D
#else
.org	ProgStart
#endif
	ret
	jr	nc,start
title:	.db	"Asteroids v0.98 by Joe P",0
start:	im	1
	call	setupINT		;set up my interrupt vector
	set	textwrite,(iy+sgrflags)	;write to the graph buffer

	ld	hl,begin_var
	ld	de,begin_var+1
	ld	bc,end_var-begin_var-1
	ld	(hl),0
	ldir			;erase vars
	call	cleartables
	ld	a,4
	call	setturnspeed	;set up turning speed
	ld	hl,190
	ld	(velocity_x),hl	;set up velocity_x for menu
	ld	h,55
	ld	(ypos),hl
	xor	a
	ld	(currow),a		;my temp timer
menuL:	ld	hl,currow
	inc	(hl)
	call	clearGR
	call	moveship
	ld	b,100
	call	ionrandom
	or	a
	jr	nz,menu_2
	ld	a,(temp)
	cpl
	ld	(temp),a
menu_2:	ld	hl,angle
	ld	a,(temp)
	or	a
	call	z,turnright
	call	nz,turnleft
	ld	hl,temp
	ld	b,20
	call	ionrandom
	or	a
	call	z,pshot
	call	handleshots
	call	putship
	ld	de,(10*256)+2
	ld	hl,(85*256)+13
	call	box
	ld	bc,(8*256)+8
	ld	a,17
	ld	l,4
	ld	ix,titlespr
	call	ionlargesprite
	ld	a,(currow)
	bit	4,a
	jr	nz,menu_3
	ld	bc,(5*256)+4
	ld	a,32
	ld	l,28
	ld	ix,enterspr
	call	ionlargesprite

menu_3:	call	ionfastcopy
	call	getkdh
	bit	5,b
	jp	z,quit
	bit	7,b
	jr	z,menuD
	call	gamedelay
	jr	menuL
menuD:	ld	de,(46*256)+35
	ld	hl,(48*256)+35
	ld	b,42+3

menuopen:
	push	bc
	push	de
	push	hl
	ld	c,1
	call	rectangle_outline
	call	ionfastcopy
	pop	hl
	pop	de
	push	hl
	push	de
	ld	c,0
	call	rectangle_filled
	pop	de
	pop	hl
	pop	bc
	bit	5,b
	jr	z,menuopen1
	dec	e
	inc	l
	ei
	halt
	halt
	jr	menudjnz
menuopen1:
	dec	d
	inc	h
menudjnz:
	djnz	menuopen
	ld	c,1
	call	rectangle_outline
	ld	a,23
	ld	(curcol),a			;(curcol) = start y coord
draw_menu_open:
	call	clearmenu
	ld	de,(23*256)+25
	ld	(pencol),de
	ld	hl,start_menu
	bcall(_vputs)
	ld	de,((23+6)*256)+38
	ld	(pencol),de
	bcall(_vputs)
	ld	de,((23+12)*256)+36
	ld	(pencol),de
	bcall(_vputs)
	ld	de,((23+18)*256)+42
	ld	(pencol),de
	bcall(_vputs)
	;ei
	;halt				;clear any keypresses so _getcsc isn't skipped
menu_open_display:
	call	putmenu
	call	ionfastcopy
	call	putmenu
menu_open_loop:
	call	getkdhd
	ld	a,b
	cp	255
	jr	nz,menu_open_not_null	;if b!=255 then an important key was pressed
	ld	hl,leveltimerLSB
	dec	(hl)	
	jr	nz,menu_open_loop
	ei
	halt
	halt
	ld	hl,leveltimer
	inc	(hl)
	ld	a,(hl)
	or	a
	jp	z,menuL
	jr	menu_open_loop
menu_open_not_null:
	ld	hl,leveltimer
	ld	(hl),0			;key was pressed - reset level timer
	bit	3,b
	jr	nz,menu_open_loop2
	ld	a,(curcol)
	sub	6
	cp	17
	jr	z,menu_open_loop2
	ld	(curcol),a
	jr	menu_open_display
menu_open_loop2:
	bit	0,b
	jr	nz,menu_open_loop3
	ld	a,(curcol)
	add	a,6
	cp	41+6
	jr	z,menu_open_loop3
	ld	(curcol),a
	jr	menu_open_display
menu_open_loop3:
	bit	7,b
	jr	nz,menu_open_loop
	call	clearmenu
	ld	a,(curcol)
	cp	35+6
	jp	z,quit
	cp	23
	jp	z,startgame
	cp	29
	jr	z,options
hiscore:
	ld	hl,hiscoretxt
	ld	de,(23*256)+32
	ld	(pencol),de
	bcall(_vputs)
	push	hl
	xor	a
	call	puthiscore
	pop	hl
	ld	de,(29*256)+28
	ld	(pencol),de
	bcall(_vputs)
	push	hl
	ld	a,1
	call	puthiscore
	pop	hl
	ld	de,(35*256)+32
	ld	(pencol),de
	bcall(_vputs)
	push	hl
	ld	a,2
	call	puthiscore
	pop	hl
	ld	de,(41*256)+20
	ld	(pencol),de
	bcall(_vputs)
	call	ionfastcopy
hiscoreL:
	call	getkdh
	bit	6,b
	jr	z,hiscoreclear
	bit	7,b
	jr	nz,hiscoreL
	jp	draw_menu_open
hiscoreclear:
	ld	hl,hiscores
	ld	a,(mode)
	ld	e,a
	add	a,e
	add	a,e
	add	a,a
	ld	e,a
	ld	d,0		;de=mode*6
	add	hl,de
	ld	d,h
	ld	e,l
	inc	de
	ld	(hl),0
	ld	bc,5
	ldir
	call	clearmenu
	jp	hiscore

options:
	call	clearmenu
	ld	hl,dificultytxt
;	ld	de,(23*256)+34
;	ld	(pencol),de
;	bcall(_vputs)
	ld	a,(dificulty)
	call	findstring
	ld	e,(hl)
	inc	hl
	ld	d,23
	ld	(pencol),de
	bcall(_vputs)
	ld	hl,modetxt
	ld	a,(mode)
	call	findstring
	ld	e,(hl)
	inc	hl
	ld	d,23+6+3
	ld	(pencol),de
	bcall(_vputs)


	ld	de,(42*256)+19
	ld	(pencol),de
	ld	hl,url
	bcall(_vputs)
	call	ionfastcopy
option_key:
	call	getkdhd
	ld	hl,dificulty
	bit	1,b
	jr	z,decdi
	bit	2,b
	jr	z,incdi
	bit	3,b
	jr	z,chmode
	bit	0,b
	jr	z,chmode
	bit	7,b
	jr	nz,option_key
	jp	draw_menu_open
incdi:	ld	a,(hl)
	inc	a
	cp	3
	jr	nz,incdi2
	xor	a
incdi2:	ld	(hl),a
	jp	options
decdi:	ld	a,(hl)
	or	a
	jr	nz,decdi2
	ld	a,3
decdi2:	dec	a
	ld	(hl),a
	jp	options
chmode:	ld	hl,mode
	ld	a,(hl)
	xor	%00000001
	ld	(hl),a
	jp	options

startgame:
	ld	hl,menui
	ld	b,5+5+6
menuiL:	push	hl
	call	ldhlind
	ld	(hl),0			;initialize all the menu flags
	pop	hl
	inc	hl
	inc	hl
	djnz	menuiL
	ld	a,1
	ld	(_e3),a			;(special) you start with this engine

	ld	a,96
	ld	(health),a	;set up health
	ld	a,6
	ld	(maxbullets),a
	ld	a,3
	ld	(lives),a		;3 lives

	call	cleartables
play:
load:	call	loadlevel
	call	clearGR
loadr:	ld	de,(17*256)+27
	ld	hl,(79*256)+37
	call	box

	ld	hl,(29*256)+20
	ld	(pencol),hl
	ld	hl,lvltxt
#ifdef TI83P
	set	fracdrawLfont,(iy+fontflags)
#endif
	bcall(_vputs)
	ld	bc,(level)		;c=level
	call	bintobcd
	ld	hl,bcdstring
	bcall(_vputs)
#ifdef TI83P
	res	fracdrawLfont,(iy+fontflags)
#endif
	call	ionfastcopy
loadw:	call	getkdh
	bit	7,b
	jr	nz,loadw
	xor	a
	ld	(EOLcounter),a

main:	ei				;make sure interrupts are enabled for my game timer
	ld	hl,hurttimer		;
	ld	a,(hl)			;if hurttimer isn't 0
	or	a			;
	jr	z,nodechurttimer	;
	dec	(hl)			;decrease it
nodechurttimer:
	ld	a,(regen)
	or	a
	jr	z,noregen
	ld	hl,regenflag
	dec	(hl)
	jr	nz,noregen		;we haven't hit zero yet
	ld	(hl),regenrate
	ld	hl,health
	ld	a,(hl)
	cp	96
	jr	nc,noregen		;health => 96
	inc	(hl)
	ld	hl,regentotal
	dec	(hl)
	jr	nz,noregen
	xor	a
	ld	(regen),a		;regen ran out!
noregen:
	ld	a,(deathflag)
	or	a
	jr	nz,norandk
	ld	a,Dreset
	out	(1),a
	ld	a,Group5
	out	(1),a
	in	a,(1)
	bit	7,a
	jr	nz,norandk
	ld	a,(randPOS)
	or	a
	jr	nz,norand
	ld	b,95+8-4
	call	ionrandom
	add	a,4
	ld	(xpos+1),a
	ld	b,63+8-4
	call	ionrandom
	add	a,4
	ld	(ypos+1),a
	ld	(randPOS),a
	jr	norand
norandK:
	xor	a
	ld	(randPOS),a
norand:	call	controlship		;turn/thrust according to keypresses
	ld	a,Dreset		;a=reset value (ffh)
	out	(1),a			;clear key port
	ld	a,Group7		;
	out	(1),a			;turn on group 7
	in	a,(1)			;get the keypress
	bit	5,a			;bit 5 = 2nd
	jp	z,shoot			;if it is zero, shoot a bullet
#ifdef DEBUGMODE
	cp	kdgraph			;
	call	z,debugme		;debug purposes
#endif
	xor	a
	ld	(shotflag),a		;2nd wasn't pressed, reset shotflag
shootret:
	ld	a,Dreset
	out	(1),a
	ld	a,Group6
	out	(1),a
	in	a,(1)
	cp	kdalpha
	jp	z,switch_2shot
	xor	a
	ld	(alphaflag),a
alpharet:
	call	clearGR			;clear graph screen
	call	moveship		;move ship according to thrust
	call	handleshots		;move shots
	call	putship			;display ship
	call	handleasteroids		;move asteroids, test for collisions
	call	puthealth		;display health bar
	call	chkpause

	call	ionfastcopy

	ld	hl,leveltimerLSB	;decrement the leveltimer sub timer
	dec	(hl)			;
	jr	nz,skipleveltimer	;if it isn't zero yet, dont decrement timer
	ld	(hl),leveltimerRATE	;reset sub timer
	ld	hl,(leveltimer)		;
	inc	hl			;increment timer
	ld	(leveltimer),hl		;save it
skipleveltimer:
#ifdef SHOWLEVELTIMER
	ld	de,0
	ld	(currow),de
	ld	hl,(leveltimer)		;debug stuff
	bcall(_disphl)
#endif
	call	gamedelay		;delay game to keep speed constant
	ld	hl,deathflag		;
	ld	a,(hl)			;a=deathflag
	cp	2			;if it is two, then we have been dead for some time
	jp	z,death			;you died!
	cp	1			;
	jp	z,deathW		;see if the ship can come back yet
	or	a
	jr	z,skipdeath
	dec	(hl)			;
	jp	main			;if you're dead, you can't win the level! hahah!
skipdeath:
	ld	hl,EOLcounter		;
	ld	a,(hl)			;a=EOLcounter
	or	a			;if EOLcounter is zero, level isn't beaten
	jr	z,checkifAS		;
	cp	1			;if it's one, we went through the entire EOL count
	jp	z,levelclear		;beat the level
	dec	(hl)			;decrement EOL counter
	jp	main			;loop back up
checkifAS:
	ld	a,(numasteroids)	;if there are still asteroids
	or	a			;
	jp	nz,main			;if there are still asteroids onscreen, don't end level
	ld	a,100			;no asteroids, so start EOL countdown
	ld	(EOLcounter),a		;End of level counter = 100
	jp	main



controlship:
	ld	a,Dreset		;
	out	(1),a			;reset the keyport
	ld	a,Group1		;
	out	(1),a			;turn the arrow keys on
	in	a,(1)			;check for arrow keypresses
	ld	hl,angle		;set up hl for turnleft and turnright
	bit	1,a			;left key
	call	z,turnleft		;if left was pressed, turn left
	bit	2,a			;right key
	call	z,turnright		;if right was pressed, turn right
	bit	3,a			;up key
	jr	z,thrust		;if up was pressed, thrust and skip retro

	ld	a,(retro)		;a=retro status
	or	a			;
	ret	z			;if we don't have retro, don't slow down

	ld	hl,(velocity_y)		;hl=y velocity
	call	fixhlr			;fix hl for retro
	ld	(velocity_y),hl		;save it
	ld	hl,(velocity_x)		;
	call	fixhlr			;fix hl for retro
	ld	(velocity_x),hl		;save it
	ret

fixhlr:	bit	7,h			;if bit 7 is on, hl is negative
	jr	nz,retroneg
	ld	de,(retrospeed)
	or	a			;clear carry flag
	sbc	hl,de			;hl=hl-retrospeed
	bit	7,h
	ret	z			;y velocity is still positive
	ld	hl,0			;kill speed
	ret
retroneg:
	ld	de,(retrospeed)
	add	hl,de
	bit	7,h
	ret	nz			;y velocity is still negative
	ld	hl,0
	ret

switch_2shot:
	ld	hl,alphaflag
	ld	a,(hl)
	or	a
	jp	nz,alpharet		;alpha hasn't been released yet
	ld	(hl),1			;you have pressed alpha
	ld	a,(doubleshot)		;if we don't have double shot yet
	or	a			;we can't switch
	jp	z,alpharet		;thus, return
	ld	a,(doubleEnable)
	xor	%00000001		;switch on/off
	ld	(doubleEnable),a
	jp	alpharet		;return





	
turnright:
	push	af			;save keypress
	ld	a,(hl)			;a=angle
_tfix1:	add	a,4			;SMC from setturnspeed
	ld	(hl),a			;save new angle
	pop	af			;restore keypress
	ret
turnleft:
	push	af			;save keypress
	ld	a,(hl)			;a=angle
_tfix2:	sub	4			;SMC from setturnspeed
	ld	(hl),a			;save new angle
	pop	af			;restore keypress
	ret
	
thrust:	call	getvelocity_Y		;hl=velocity
	ld	de,(velocity_y)
	add	hl,de
	ld	a,h
	cp	3
	jr	z,thrustx
	cp	-3
	jr	z,thrustx
	ld	(velocity_y),hl
thrustx:
	call	getvelocity_x
	ld	de,(velocity_x)
	add	hl,de
	ld	a,h
	cp	3
	ret	z
	cp	-3
	ret	z
	ld	(velocity_x),hl
	ret
#ifdef DEBUGMODE
debugme:
	bcall(_homeup)
	ld	hl,(numasteroids)
	ld	h,0
	bcall(_disphl)
	bcall(_newline)
	ld	hl,(money)
	bcall(_disphl)
	bcall(_newline)
	ld	hl,(health)
	ld	h,0
	bcall(_dispHL)
	bcall(_newline)
dfix:	ld	l,0
	ld	h,0
	bcall(_disphl)
	call	waitk
	ret
#endif

schkr:	ld	a,(rapidfire)
	or	a
	jp	z,shootret
	ld	hl,rapidfiretimer
	ld	a,(hl)
	or	a
	jr	z,resetforrapid
	dec	(hl)
	jp	shootret
resetforrapid:
	ld	(shotflag),a		;shotflag = 0
	ld	(hl),2
	jp	shootret


;TTL, xcoord(2), ycoord(2), xspeed(2), yspeed(2)
shoot:
	ld	a,(deathflag)
	or	a
	jp	nz,shootret		;if you're dead, you can't shoot
	ld	a,(shotflag)
	or	a
	jr	nz,schkr

	ld	a,(doubleEnable)
	or	a
	jr	z,shot1
	ld	a,(doubleshot)
	or	a
	jr	nz,shot2
shot1:	call	pshot
	jp	shootret
shot2:	ld	a,(angle)
	push	af
	sub	8
	ld	(angle),a
	call	pshot
	pop	af
	push	af
	add	a,8
	ld	(angle),a
	call	pshot

	pop	af
	ld	(angle),a
	jp	shootret

pshot:	ld	hl,shottable
	ld	bc,(maxbullets-1)	;b=maxbullets, c=??
	ld	de,9
shootL:	ld	a,(hl)
	or	a
	jr	z,shootG
	add	hl,de
	djnz	shootL
	ret
shootG:	ld	a,1
	ld	(shotflag),a
	ld	(hl),shotTTL
	push	hl
	pop	ix
	call	getanglex2HL
	ld	de,bullet_entry_table
	add	hl,de		;
	ld	a,(xpos+1)	;
	add	a,(hl)		;
	ld	(ix+2),a	;MSB of xcoord
	ld	a,(xpos)	;
	ld	(ix+1),a	;LSB of xcoord
	inc	hl		;
	ld	a,(ypos+1)	;
	add	a,(hl)		;
	ld	(ix+4),a	;MSB of xcoord
	ld	a,(ypos)	;
	ld	(ix+3),a	;LSB of xcoord
	call	getanglex2HL
	ld	de,bullet_velocity
	add	hl,de
	call	ldhlind		;hl=(hl)
	ld	de,(velocity_x)
	add	hl,de
	ld	(ix+5),l
	ld	(ix+6),h

	call	getanglex2HL
	ld	de,16+32
	add	hl,de
	ld	a,l
	and	%00111111
	ld	l,a
	ld	de,bullet_velocity
	add	hl,de
	call	ldhlind		;hl=(hl)
	ld	de,(velocity_y)
	add	hl,de

	ld	(ix+7),l
	ld	(ix+8),h
	ret


;TTL, xcoord(2), ycoord(2), xspeed(2), yspeed(2)
handleshots:
	ld	a,2
	call	SetHeightXOR		;set up height for putsprclpXOR
	ld	ix,shottable
	ld	b,maxshots		;b=max bullets
	ld	hl,shottemptable	;xcoord, ycoord, lsb of pointer, msb of pointer
	ld	(hl),0			;start table with zero entries
	inc	hl
hshotL:	ld	a,(ix+0)
	or	a
	jr	z,skipshot		;no shot here
	push	bc			;save counter
	dec	(ix+0)			;decrement shot TTL
	ld	b,(ix+2)		;
	ld	c,(ix+4)		;bc=xy
	ld	(hl),b			;save the x coord
	inc	hl			;
	ld	(hl),c			;save the y coord
	inc	hl			;
	push	ix			;
	pop	de			;de points to the start of the shot entry
	ld	(hl),e			;save the LSB of the pointer to this shot
	inc	hl			;
	ld	(hl),d			;save the MSB of the pointer to this shot
	inc	hl			;
	push	hl			;save hl
	ld	hl,shottemptable
	inc	(hl)			;increment number of shots
	ld	hl,shotspr		;hl points to the shot sprite
	push	ix			;save ix
	call	putsprclpXOR		;display the shot
	pop	ix			;restore ix
	ld	h,(ix+2)		;
	ld	l,(ix+1)		;hl = current x coord
	ld	d,(ix+6)		;
	ld	e,(ix+5)		;de = x speed
	add	hl,de			;find new x coord
	bit	7,h			;if hl is still positive
	jr	z,hshot1		;skip this
	ld	hl,(96+7)*256		;move the shot to the right side of the screen
hshot1:	ld	a,h			;a=MSB of the xcoord of the shot
	cp	96+8			;if the shot isn't past the right bound
	jr	c,hshot2		;skip this:
	ld	hl,0			;set the shot to the left side
hshot2:	ld	(ix+2),h		;
	ld	(ix+1),l		;save updated x coord

	ld	h,(ix+4)
	ld	l,(ix+3)
	ld	d,(ix+8)
	ld	e,(ix+7)
	add	hl,de            

	bit	7,h
	jr	z,hshot3
	ld	hl,(64+7)*256
hshot3:	ld	a,h
	cp	64+8
	jr	c,hshot4
	ld	hl,0
hshot4:	ld	(ix+4),h
	ld	(ix+3),l
	pop	hl			;restore pointer to the shottemptable
	pop	bc			;restore the counter
skipshot:
	ld	de,9
	add	ix,de			;go to the next shot
	djnz	hshotL
	ret

;a=size
;0=large, 1=medium, 2=small, 3=money, 4=health
;de = xy
;
;alive, type, xcoord(2), ycoord(2), xspeed, yspeed
;
putasteroid:
	cp	3
	jr	c,putas1
	ld	b,20
	jr	putas2
putas1:	ld	b,maxasteroids
putas2:	ld	hl,asteroidtable
	push	af
	push	de
	ld	de,12
paL:	ld	a,(hl)
	or	a
	jr	z,paG
	add	hl,de
	djnz	paL
	pop	de
	pop	af
	ret
PaG:	pop	de
	pop	af
	ld	(hl),1		;asteroid here
	inc	hl		;
	ld	(hl),a		;asteroid type
	push	af
	inc	hl		;
;	ld	(hl),0		;LSB of asteroid xcoord
	inc	hl		;
	ld	(hl),d		;MSB of asteroid xcoord
	inc	hl		;
;	ld	(hl),0		;LSB of asteroid ycoord
	inc	hl		;
	ld	(hl),e		;MSB of asteroid ycoord
	inc	hl
	call	makevel
	ld	(hl),e
	inc	hl
	ld	(hl),d
	inc	hl
	call	makevel
	ld	(hl),e
	inc	hl
	ld	(hl),d

	pop	af
	cp	3
	jr	nc,setTTL
	ld	hl,numasteroids
	inc	(hl)
	ret
setTTL:	ld	de,moneyTTL
	inc	hl
	ld	(hl),e
	inc	hl
	ld	(hl),d
	ret
makevel:
	ld	b,240
	call	ionrandom
	push	hl
	ld	l,a
	ld	h,0
	ld	de,120
	or	a		;clear carry flag
	sbc	hl,de
	ex	de,hl
	pop	hl
	ret

;alive, type, xcoord(2), ycoord(2), xspeed(2), yspeed(2)
handleasteroids:
	call	createshiptemptable

	ld	ix,asteroidtable
	ld	b,maxasteroids
haL:	ld	a,(ix+Aalive)
	or	a
	jp	z,aSkip
	push	bc
	
	ld	a,(ix+Atype)			;a=object type
	cp	3
	jr	c,ha2			;not money, we don't have to worry about TTL
	ld	l,(ix+mTTLlsb)		
	ld	h,(ix+mTTLmsb)		;hl=ttl
	dec	hl			;decrement TTL
	ld	(ix+mTTLlsb),l
	ld	(ix+mTTLmsb),h		;update TTL
	ld	a,l
	or	h			;if hl=zero, kill the money
	jr	nz,ha2
	ld	(ix+Aalive),0		;kill the money!
	jp	askipbc
ha2:	call	checkcollision		;check for collisions

	ld	l,(ix+Atype)
	ld	h,0
	add	hl,hl
	add	hl,hl
	add	hl,hl
	ld	de,asteroidsprites
	add	hl,de		;hl points to the asteroid sprite
	ld	b,(ix+3)
	ld	c,(ix+5)
	push	ix
	call	putsprclpXOR
	pop	ix
	ld	l,(ix+2)
	ld	h,(ix+3)
	ld	e,(ix+6)
	ld	d,(ix+7)
	add	hl,de
	bit	7,h
	jr	z,has1
	ld	hl,(96+7)*256
has1:	ld	a,h
	cp	96+8
	jr	c,has2
	ld	hl,0
has2:	ld	(ix+2),l
	ld	(ix+3),h

	ld	l,(ix+4)
	ld	h,(ix+5)
	ld	e,(ix+8)
	ld	d,(ix+9)
	add	hl,de
	bit	7,h
	jr	z,has3
	ld	hl,(64+7)*256
has3:	ld	a,h
	cp	64+8
	jr	c,has4
	ld	hl,0
has4:	ld	(ix+4),l
	ld	(ix+5),h

aSkipbc:
	pop	bc
aSkip:	ld	de,12
	add	ix,de
	dec	b			;can't use djnz
	jp	nz,haL			;because there is too much code for relative jump
	ret

;alive, type, xcoord(2), ycoord(2), xspeed(2), yspeed(2), ttl(2)
;
;(ix) = start of asteroid entry
;(shottemptable) = how many bullets
;(shottemptable+1) = coords (x,y), pointer to bullet entry
checkcollision:
	ld	a,(ix+Atype)	;a=asteroid type
	or	a		;z=large
	jr	z,checkaLARGE	;
	dec	a		;if a was 1..
	jr	z,checkaMED	;
	dec	a		;if a was 2..
	jr	z,checkaSMALL	;
	dec	a		;if a was 3..
	jr	z,checkaMONEY	;
checkaHEALTH:			;otherwise, a was 4
	ld	a,6		;health is 6 wide
	ld	(_fix3+1),a
	ld	(_fix4+1),a
	jp	checkshipcollision	;dont check for shot collisions
checkaMONEY:
	ld	a,7		;money is 7 wide
	ld	(_fix3+1),a	;
	ld	(_fix4+1),a	;
	jp	checkshipcollision	;dont check for shot collisions
checkaSMALL:
	ld	a,4		;small asteroids are 4 wide
	jr	checkas		;
checkaMED:			;
	ld	a,6		;medium asteroids are 6 wide
	jr	checkas		;
checkALARGE:			;
	ld	a,8		;large asteroids are 8 wide
checkas:
	ld	(_fix1+1),a	;
	ld	(_fix2+1),a	;set all the widths for the collision checking
	ld	(_fix3+1),a	;
	ld	(_fix4+1),a	;
	ld	a,(shottemptable)
	or	a
	jp	z,checkshipcollision	;if no bullets, check ship collision
	ld	b,a		;b=counter
	ld	hl,shottemptable+1
chkaL:	push	hl
	ld	a,(ix+AxMSB)	;a=asteroid xcoord
	cp	(hl)
	jr	nc,chkaLSKIP	;asteroid is to the left of the bullet
_fix1:	add	a,0		;a=right xcoord of asteroid
	cp	(hl)		;compare it to the xcoord of the bullet
	jr	c,chkaLSKIP	;it is to the right of the bullet
	inc	hl		;(hl)=bullet y coord
	ld	a,(ix+AyMSB)	;a=asteroid y coord
	cp	(hl)		;
	jr	nc,chkaLSKIP	;asteroid was below the bullet
_fix2:	add	a,0		;
	cp	(hl)		;
	jr	c,chkaLSKIP	;asteroid was above the bullet
	xor	a		;
	inc	hl		;
	ld	e,(hl)		;
	inc	hl		;
	ld	d,(hl)		;de points to the entry in the shot table for this bullet
	ld	(de),a		;kill the bullet

	push	bc		;save the counter
	ld	e,(ix+Atype)	;e=object type
	inc	e		;e=e+1 (small asteroid=3 pts, med=2 pts, large=1 pt)
	call	addscore1
	call	killasteroid	;
	ld	hl,shottemptable
	dec	(hl)		;decrement number of shots in temp table (we just killed one)
	pop	bc		;restore the counter
	pop	hl		;hl= start of the current shottemptable entry
	ld	d,h
	ld	e,l
	;ex	de,hl		;de= start of the current shottemptable entry, hl=random stuff
	inc	hl		;
	inc	hl		;
	inc	hl		;
	inc	hl		;hl points to the next shottemptable entry
	ld	bc,maxshots*4
	ldir			;copy rest of bullets back one entry
	ret			;asteroid is DEAD!! muahahah!
chkaLSKIP:
	pop	hl
	ld	de,4
	add	hl,de
	djnz	chkAL		;once we have looped through shot checking, check col. with ship


;alive, type, xcoord(2), ycoord(2), xspeed, yspeed
;
;(ix) = start of asteroid entry
;(shiptemptable) = 6 (x,y) pairs of coords to check
checkshipcollision:
	ld	a,(deathflag)
	or	a
	ret	nz		;if we're dead, we can't collide with any asteroids =D
	ld	b,6		;6 ship coords to check
	ld	hl,shiptemptable	;this holds x,y pairs of 6 coords to check for collision	
chkSl:	ld	a,(ix+AxMSB)	;a=msb of x of asteroid
	cp	(hl)		;compare it to the ship x coord
	jr	nc,chksLSKIP1	;asteroid is to the right of the coord
_fix3:	add	a,0		;SMC
	cp	(hl)		;
	jr	c,chksLSKIP1	;asteroid is to the left of the coord
	inc	hl		;
	ld	a,(ix+AyMSB)	;a=msb of y of asteroid
	cp	(hl)		;compare it to the ship y coord
	jr	nc,chksLSKIP2	;asteroid is below the coord
_fix4:	add	a,0		;SMC
	cp	(hl)		;
	jr	c,chksLSKIP2

#ifndef INVINCIBLE
	ld	a,(ix+Atype)
	cp	3
	call	c,hurtme	;if you hit an asteroid, you get hurt
#endif				;
	jr	killasteroid	;kill the asteroid/powerup!
chksLSKIP1:			;
	inc	hl		;go to y in the x,y pair
chksLSKIP2:			;
	inc	hl		;go to next x,y pair
	djnz	chkSl		;loop back
	ret			;return, collision free!


;ix = pointer to asteroid entry
killasteroid:
	ld	(ix+Aalive),0	;kill the asteroid

	ld	a,(ix+Atype)
	cp	4
	jr	z,yeshealth	;type 4 = health powerup
	cp	3
	jr	nz,nopowerup	;if it isn't type 3 (money), it isn't a powerup
	ld	hl,moneytable
	ld	de,(dificulty)
	ld	d,0
	add	hl,de
	ld	e,(hl)		;de=money you get
	ld	hl,(money)	;it is money!
	add	hl,de		;
	ld	(money),hl	;save it
	jr	yh3
yeshealth:
	ld	a,(health)
	add	a,8
	cp	96
	jr	c,yh2		;if health < 96	
	ld	a,96
yh2:	ld	(health),a
yh3:	ld	e,5
	jp	addscore1

nopowerup:
	ld	hl,numasteroids
	dec	(hl)		;decrement number of asteroids
	cp	2
	ret	nc		;if the type is 2 or greater, leave

	push	af		;save asteroid type
	ld	a,(mode)
	or	a
	jr	nz,noputmoney
	ld	b,moneyrate
	call	ionrandom
	or	a
	jr	nz,noputmoney
	ld	d,(ix+AxMSB)
	ld	e,(ix+AyMSB)
	ld	a,3
	call	putasteroid
noputmoney:
	ld	b,healthrate
	call	ionrandom
	or	a
	jr	nz,noputhealth
	ld	d,(ix+AxMSB)
	ld	e,(ix+AyMSB)
	ld	a,4
	call	putasteroid
noputhealth:
	pop	af
	ld	d,(ix+AxMSB)	;
	ld	e,(ix+AyMSB)	;set up coords for new asteroid
	inc	a		;a=new asteroid type
	push	de
	call	putasteroid
	pop	de
#ifdef THREE_ENEMIES
	push	de
	call	putasteroid
	pop	de
#endif
	jp	putasteroid







moveship:
	ld	hl,(ypos)
	ld	de,(velocity_y)
	add	hl,de
	ld	(ypos),hl
	ld	a,(ypos+1)
	cp	64+8
	jr	c,movecont1
	ld	hl,0
	ld	(ypos),hl
movecont1:
	bit	7,a
	jr	z,movecont2
	ld	hl,(64+7)*256
	ld	(ypos),hl
movecont2:
	ld	hl,(xpos)
	ld	de,(velocity_x)
	add	hl,de
	ld	(xpos),hl
	ld	a,(xpos+1)
	cp	96+8
	jr	c,movecont3
	ld	hl,0
	ld	(xpos),hl
movecont3:
	bit	7,a
	ret	z
	ld	hl,(96+7)*256
	ld	(xpos),hl
	ret




createshiptemptable:
	ld	hl,(angle)
	srl	l
	srl	l
	srl	l
	ld	h,0			;hl=angle/8
	ld	d,h
	ld	e,l
	add	hl,hl
	add	hl,de
	add	hl,hl
	add	hl,hl			;hl=hl*12
	ld	de,ship_col_table
	add	hl,de
	ld	b,6
	ld	de,shiptemptable
makeshiptemptable:
	push	bc
	ld	a,(xpos+1)
	add	a,(hl)			;a=x of point to check
	ld	(de),a
	inc	de
	inc	hl
	ld	a,(ypos+1)
	add	a,(hl)
	ld	(de),a
	inc	de
	inc	hl
	pop	bc
	djnz	makeshiptemptable
	ret


puthealth:
	ld	a,(deathflag)
	or	a
	ret	nz

	ld	a,(health)
	or	a
	ret	z		;we don't have health.. don't draw it

	ld	de,(0*256)+63
	ld	b,a
	ld	c,1
	jp	h_line




ldhlind:			;wrote this routine out
	ld	a,(hl)		;so i don't have to waste
	inc	hl		;time bcalling
	ld	h,(hl)		;
	ld	l,a		;
	ret			;


cleartables:
	ld	hl,shottable
	ld	de,shottable+1
	ld	(hl),0
	ld	bc,(maxshots*9)+(maxasteroids*12)-1
	ldir
	ret
clearGR:
	ld	hl,plotsscreen
	ld	de,plotsscreen+1
	ld	bc,767
	ld	(hl),0
	ldir
	ret

clearmenu:
	ld	de,(18*256)+22
	ld	hl,(76*256)+48
	ld	c,0
	jp	rectangle_filled


gamedelay:

	ld	hl,timecounter
	ld	a,4
	sub	(hl)		;a=how many times to delay
#ifdef DEBUGTIMER
	push	hl
	push	af
	ld	hl,0
	ld	(currow),hl
	ld	l,a
	ld	h,0
	bcall(_disphl)
	pop	af
	pop	hl
#endif
	jr	c,delayD
delayL:	or	a
	jr	z,delayD
	ei
	halt
	dec	a
	jr	delayL
delayD:
	ld	(hl),0
	ret


;sets up the game's interrupt vector
setupINT:
	di
	ld	hl,interrupt_table
	ld	de,interrupt_table+1
	ld	bc,$100
	ld	(hl),interrupt_vector_byte
	ldir			;set up interrupt vector table

	ld	hl,interrupt_start
	ld	de,interrupt_vector
	ld	bc,interrupt_end-interrupt_start
	ldir			;copy interrupt routine

	ld	a,interrupt_table_byte
	ld	i,a
	im	2
	ei
	ret

;sets up all the level stuff
loadlevel:
	ld	a,(level)
	inc	a
	jr	load1
reloadlevel:
	ld	a,(level)
load1:	ld	(level),a
	cp	20
	jr	c,moreas
	ld	a,20
moreas:
	add	a,2
	ld	b,a

	ld	hl,0
	ld	(leveltimer),hl
	ld	a,leveltimerRATE
	ld	(leveltimerLSB),a

	ld	hl,numasteroids
	ld	(hl),0		;zero asteroids right now
lvlL:	push	bc
getH:	ld	b,96+8
	call	ionrandom
	cp	screen_as_buffer+8
	jr	c,goodH
	cp	96-screen_as_buffer-8
	jr	c,getH
goodH:	ld	d,a
getV:	ld	b,64+8
	call	ionrandom
	cp	screen_as_buffer+8
	jr	c,goodv
	cp	64-screen_as_buffer-8
	jr	c,getV
goodV:	ld	e,a
	xor	a		;large asteroid
	call	putasteroid
	pop	bc
	djnz	lvlL

				;carry into centership
centership:
	ld	hl,(52*256)+0
	ld	(xpos),hl
	ld	hl,(36*256)+0
	ld	(ypos),hl
	ld	hl,0
	ld	(velocity_y),hl
	ld	(velocity_x),hl
	xor	a
	ld	(angle),a
	ret

chkpause:
	ld	a,Dreset
	out	(1),a
	ld	a,Group7
	out	(1),a
	in	a,(1)
	bit	6,a
	ret	nz

pause:	ld	de,(29*256)+33		;
	ld	hl,(45*256)+38		;
	ld	(op1),de		;
	ld	(op1+2),hl		;
pauseL:	ld	de,(20*256)+25		;
	ld	hl,(76*256)+40		;
	call	box			;
	ld	hl,(26*256)+24		;
	ld	(pencol),hl		;
	ld	hl,pausedtxt		;
	bcall(_vputs)			;display "paused"
	ld	hl,(lives)
	ld	h,0
	call	dispvhl
	ld	hl,livestxt
	bcall(_vputs)

	ld	hl,(33*256)+30
	ld	(pencol),hl
	ld	hl,conttxt
	bcall(_vputs)			;display "Cont"

	ld	hl,(33*256)+52
	ld	(pencol),hl
	ld	hl,quittxt
	bcall(_vputs)			;display "Quit"

	ld	de,(op1)
	ld	hl,(op1+2)
	ld	c,2
	call	rectangle_filled	;draw selector

	call	ionfastcopy
pauseK:	call	getkdh
	bit	1,b
	jr	z,pauseleft
	bit	2,b
	jr	z,pauseright
	bit	7,b
	jr	nz,pauseK
	ld	a,(op1+1)
	cp	29
	ret	z
	pop	af			;pop the call
	jr	endgame

pauseleft:
	ld	a,29
	jr	pupdate
pauseright:
	ld	a,51
pupdate:
	ld	(op1+1),a
	add	a,15
	ld	(op1+3),a
	jr	pauseL

endgame:
	ld	a,(dificulty)
	add	a,a
	ld	hl,(mode)
	ld	h,0
	ld	d,h
	ld	e,l
	add	hl,de
	add	hl,de
	add	hl,hl
	ld	e,a
	add	hl,de
	ld	de,hiscores
	add	hl,de
	push	hl
	call	ldhlind
	ld	de,(score)
	bcall(_cphlde)
	pop	hl
	jp	nc,start
	ld	(hl),e
	inc	hl
	ld	(hl),d
	ld	de,(20*256)+25
	ld	hl,(76*256)+40
	call	box
	ld	de,(27*256)+34
	ld	(pencol),de
	ld	hl,gethiscore
	bcall(_vputs)
	ld	de,(33*256)+28
	ld	(pencol),de
	ld	hl,LEVELscore
	bcall(_vputs)
	ld	hl,(score)
	call	dispvhl
	call	waitkc
	jp	start


hurtme:	ld	hl,hurttimer
	ld	a,(hl)
	dec	(hl)		;decrement the timer cause we got hit..
	jr	z,hurtme0	;
	dec	(hl)		;
	or	a		;if its not zero..
	ret	nz		;bam!
hurtme0:
	ld	(hl),6		;dont get hurt for 6 frames or for 3 more asteroids (whichever is first)
	call	getdamage	;a=ship health, (hl)=damage
	sub	(hl)		;subtract it from the current health
	ld	(health),a	;save the new health
	jr	c,killme	;if we underflowed, the ship is DEAD!!!
	or	a
	ret	nz		;if health isn't zero, return
killme:	ld	a,100		;a=100
	ld	(deathflag),a	;deathflag=100
	ld	a,15
	ld	(explosioncnt),a
	ret

;e=points
addscore1:
	ld	d,0
;de=points
addscore:
	ld	hl,(score)
	add	hl,de
	ld	(score),hl
	ret




getvelocity_y:
	ld	hl,(engine)
getvelocity_y_l:
	ld	h,0
	call	hlx64
	push	hl
	call	getanglex2HL
	pop	de
	add	hl,de
	ld	de,velocitytables
	add	hl,de
	jp	ldHLind		;hl=(hl)
getvelocity_x:
	ld	hl,(engine)
getvelocity_x_l:
	ld	h,0
	call	hlx64		;hl=hl*64
	push	hl
	call	getanglex2HL	;hl=angle*2
	ld	de,16		;
	add	hl,de		;add 16 for the offset for the x (sine) value
	ld	a,l
	and	%00111111
	ld	l,a
	ld	h,0		;make it carry over (0-255)
	pop	de		;de=table offset
	add	hl,de		;hl=table offset+angle offset
	ld	de,velocitytables
	add	hl,de		;(hl)=velocity
	jp	ldHLind		;hl=(hl)

hlx64:	add	hl,hl		;*2
	add	hl,hl		;*4
	add	hl,hl		;*8
	add	hl,hl		;*16
	add	hl,hl		;*32
	add	hl,hl		;*64
	ret
getanglex2HL:
	ld	hl,(angle)
	srl	l
	srl	l
	srl	l		;l=angle/8
	ld	h,0		;hl=angle/8
	add	hl,hl		;hl=(angle/8)*2
	ret

waitkC:	call	ionfastcopy
waitk:	call	getkdh
	bit	7,b
	jr	nz,waitk
	ret

findstring:
	or	a
	ret	z
	call	next0
	dec	a
	jr	findstring



option_foundstring:
;a=speed to turn at
setturnspeed:
	ld	(_tfix1+1),a		;SMC
	ld	(_tfix2+1),a		;set up turning speed
	ret

;alive, type, xcoord(2), ycoord(2), xspeed(2), yspeed(2)
death:	ld	hl,lives	;death handling routine
	ld	a,(hl)		;a=current lives
	dec	(hl)		;decrement current lives
	or	a		;if we have no lives left..
	jp	z,endgame	;end this game
deathW:	ld	hl,deathflag
	ld	(hl),1
	ld	ix,asteroidtable
	ld	b,maxasteroids
deathL:	ld	a,(ix+0)
	or	a
	jr	z,deathS
	ld	a,(ix+1)
	cp	3
	jr	nc,deathS
	ld	a,(ix+AxMSB)
	cp	47-8+1-deathbuf+8
	jr	c,deathS
	cp	47+8+deathbuf+8
	jr	nc,deathS
	ld	a,(ix+AyMSB)
	cp	32-8-deathbuf+8
	jr	c,deathS
	cp	32+8+deathbuf+8
	jp	c,main
deathS:	ld	de,12
	add	ix,de
	djnz	deathL
	call	centership
	xor	a
	ld	(deathflag),a	;you're not dead
	ld	a,96
	ld	(health),a	;restore health
	jp	main


puthiscore:
	add	a,a		;a=a*2
	ld	hl,(mode)	;
	ld	h,0		;hl=mode
	ld	d,h		;
	ld	e,l		;
	add	hl,de		;
	add	hl,de		;
	add	hl,hl		;hl=mode*6
	ld	e,a
	add	hl,de
	ld	de,hiscores
	add	hl,de
	call	ldhlind
dispvhl:
	ld	d,h
	ld	e,l
dispvde:
	call	bintobcd16
	ld	hl,bcd16string
	bcall(_vputs)
	ret


;	BINTOBCD
;   by Joe Pemberton
;size: 69 bytes
;
;input:
;c=number to convert
;
;returns H,L,E as HUNDREDS, TENS, ONES
;(bcdstring) contains the formatted bcd ascii string
;bc = 0
bintobcd:
	ld	b,8		;loop for 8 bits
	ld	hl,0		;h=hundreds, l=tens
	ld	e,l		;e=ones
bcdL:	ld	a,e
	cp	5
	jr	c,bcd1
	add	a,3
	ld	e,a
bcd1:	ld	a,l
	cp	5
	jr	c,bcd2
	add	a,3
	ld	l,a
bcd2:	sla	c		;shift the bit from the number off
	rl	e		;shift the bit into the ones
	bit	4,e
	jr	z,bcdb1
	res	4,e
	scf
bcdb1:	rl	l
	bit	4,l
	jr	z,bcdb2
	res	4,l
	scf
bcdb2:	rl	h
	djnz	bcdL
	ld	a,h
	add	a,$30
	ld	(bcdstring),a
	ld	a,l
	add	a,$30
	ld	(bcdstring+1),a
	ld	a,e
	add	a,$30
	ld	(bcdstring+2),a
	ret
bcdstring:
	.db	$00,$00,$00,$00	;zero terminated string of the bcd number

;	BINTOBCD16
;   by Joe Pemberton
;size: 97 bytes
;
;input:
;de=number to convert
;
;returns (bcd16) as TEN THOUSANDS, THOUSANDS, HUNDREDS, TENS, ONES
;(bcd16string) contains the formatted bcd ascii string
;b = 0
;de = 0
;destroys af, bc, de, hl, ix
bintobcd16:
	push	de
	ld	hl,bcd16
	ld	de,bcd16+1
	ld	bc,10
	ld	(hl),0
	ldir
	pop	de
	ld	b,16
bcd16L:	ld	hl,bcd16
	push	bc
	ld	b,5
bcd16I:	ld	a,(hl)
	cp	5
	jr	c,bcd16a
	add	a,3
	ld	(hl),a
bcd16a:	inc	hl
	djnz	bcd16I
	dec	hl		;hl now points to the ONES
	ld	b,5
	sla	e
	rl	d
bcd16b:	rl	(hl)
	bit	4,(hl)
	jr	z,bcd16c
	res	4,(hl)
	scf
bcd16c:	dec	hl
	djnz	bcd16b
	pop	bc
	djnz	bcd16L
	inc	hl
	ld	ix,bcd16string
	ld	bc,(5*256)+0
bcd16d:	ld	a,(hl)
	add	a,$30
	ld	(ix+0),a
	cp	$30
	jr	nz,bcd16e
	bit	1,c
	jr	z,bcd16f
bcd16e:	inc	ix
	set	1,c
bcd16f:	inc	hl
	djnz	bcd16d
	ret

bcd16:	.db	0,0,0,0,0
bcd16string:
	.db	0,0,0,0,0,0


delay:	ei
	halt
	djnz	delay
	ret

;returns b:
;bit 0 - down
;bit 1 - left
;bit 2 - right
;bit 3 - up
;bit 4 - 2nd
;bit 5 - mode
;bit 6 - clear
;bit 7 - enter
;
getkdhd:
	ld	bc,(255*256)+9
getkdhdl:
	push	bc
	call	getkdh
	ld	a,b
	pop	bc
	and	b
	ld	b,a
	ei
	halt
	dec	c
	jr	nz,getkdhdl
	halt
	halt
	halt
	ret
getkdh:	call	getkd
	ld	hl,getkdflag
	ld	a,b
	ld	c,b
	or	(hl)
	ld	b,a
	ld	a,c
	cpl
	and	%11110000
	ld	(hl),a
	ret

getkd:	ld	a,Dreset
	ld	b,a
	out	(1),a
	ld	a,Group1
	out	(1),a
	in	a,(1)
	and	b
	ld	b,a		;bits 0,1,2,3 are the arrows
	ld	a,Dreset
	out	(1),a
	ld	a,Group2
	out	(1),a
	in	a,(1)		;catch enter/clear keypress
	or	%10111110	;only get enter/clear keypress
	rrca			;enter keypress is in bit 7, clear in bit 5
	bit	5,a
	jr	nz,getkd2
	xor	%01100000
getkd2:
	and	b
	ld	b,a		;bit 7 is the enter key
	ld	a,Dreset
	out	(1),a
	ld	a,Group7
	out	(1),a
	in	a,(1)
	rra
	or	%11001111	;only get 2nd/mode
	and	b
	ld	b,a
	ret
getkdflag:
	.db 0
getdamage:
	ld	hl,(dificulty)
	ld	h,0
	add	hl,hl		;*2
	add	hl,hl		;*4
	ld	de,(armor)	;e=armor
	ld	d,0		;de=armor
	add	hl,de
	ld	de,armortable	;de=start of armor table
	add	hl,de		;hl points to the damage we recieve
	ld	a,(health)	;a=ship's health
	ret

putship:
	ld	a,8
	call	SetHeightXOR
	ld	a,(deathflag)
	or	a
	jr	z,putshipG	;if you're not dead, display ship
	ld	hl,explosioncnt
	ld	a,(hl)
	or	a
	ret	z
	dec	(hl)
	and	%00111100
	sla	a
	ld	l,a
	ld	h,0
	ld	de,explosionspr
	add	hl,de
	jr	putshipxy
putshipG:
	ld	a,(angle)	;a=angle of ship
	and	%11111000
	ld	l,a
	ld	h,0
	ld	de,shipspr
	add	hl,de
putshipxy:
	ld	bc,(ypos+1)
	ld	a,(xpos+1)
	ld	b,a
;----------------------------------------------------------------------------
;[ PutSprClpXOR ] [ABCDEFIX]                      [ 139 bytes ] [ CrASH_Man ]
;----------------------------------------------------------------------------
; Draws a sprite using only XOR data, with clipping
;
; parameters: HL -> sprite, (B,C) = coordinates
; returns:    Puts sprite in GRAPH_MEM
;
PutSprClpXOR:
	ld	a,b
	sub	8
	ld	b,a
	ld	a,c
	sub	8
	ld	c,a
	   XOR  A
__XChange_1:    LD   DE, DefaultXSpriteHeight     ; D = 0, E = Height

                OR   C                            ; If C < 0
                JP   M, _SCX_NoBotClp             ; No bottom clip.

                LD   A, $3F                       ; Is C is offscreen?
                SUB  C
                RET  C

__XChange_2:    CP   DefaultXSpriteHeight-1       ; If C + 7 < 64
                JR   NC, _SCX_NoVertClp           ; No vertical clip.
                INC  A
                LD   E, A
                JR   _SCX_NoVertClp               ; Height = 64 - C

_SCX_NoBotClp:
__XChange_3:    CP   -(DefaultXSpriteHeight-1)    ; Is C is offscreen?
                RET  C

                ADD  A, E                         ; Find how many lines
                LD   C, A                         ; to actually draw
                SUB  E

                NEG
                LD   E, A
                ADD  HL, DE                       ; Move HL down
                LD   E, C                         ; by -C lines
                LD   C, D

_SCX_NoVertClp: PUSH HL                           ; IX -> Sprite
                POP  IX

                LD   A, $77                       ; OP code for
                LD   (_SCX_OPchg_1), A            ;   LD   (HL), A
                LD   (_SCX_OPchg_2), A

                XOR  A                            ; Is B > 0?
                OR   B
                JP   M, _SCX_NoRightClp

                CP   89                           ; Is B < 89?
                JR   C, _SCX_ClpDone
                CP   96
                RET  NC

                LD   HL, _SCX_OPchg_1             ; Modify LD to NOP
                JR   _SCX_ClpModify

_SCX_NoRightClp: CP   -7                           ; Is B is offscreen?
                RET  C

                LD   HL, _SCX_OPchg_2             ; Modify LD to NOP
_SCX_ClpModify: LD   (HL), D

_SCX_ClpDone:   LD   B, D
                LD   H, B
                LD   L, C
                ADD  HL, BC                       ; HL = Y * 12
                ADD  HL, BC
                ADD  HL, HL
                ADD  HL, HL

                LD   C, A                         ; HL = Y*12 + X/8
                SRA  C
                SRA  C
                SRA  C
                INC  C

                ADD  HL, BC
                LD   BC, plotsscreen
                ADD  HL, BC

                LD   B, E                         ; B = number of rows

                CPL
                AND  %00000111                    ; find number of
                LD   E, A                         ; instructions to jump
                ADD  A, E
                ADD  A, E
                LD   (_SCX_OPchg_3 + 1), A        ; 3 * (7 - number)

                LD   DE, 13

_SCX_LineLoop:  LD   C, (IX)
                XOR  A
_SCX_OPchg_3:   JR   _SCX_OPchg_3                 ; modify

                RR   C
                RRA
                RR   C
                RRA
                RR   C
                RRA
                RR   C
                RRA
                RR   C
                RRA
                RR   C
                RRA
                RR   C
                RRA

                OR  (HL)                         ; OR with background
_SCX_OPchg_1:   LD   (HL), A                      ; Write
                DEC  HL                           ; HL -> next 8 pixels

                LD   A, C
                OR  (HL)                         ; OR with background
_SCX_OPchg_2:   LD   (HL), A                      ; Write
                ADD  HL, DE                       ; HL -> next row

                INC  IX                           ; Increment to next data
                DJNZ _SCX_LineLoop
                RET

;----------------------------------------------------------------------------
;[ SetHeightXOR ] [A]                              [ 13 bytes ] [ CrASH_Man ]
;----------------------------------------------------------------------------
; Changes the default sprite size for the XOR routine
;
; parameters: A = New Sprite Height
; returns:    Self modified routine.
;
SetHeightXOR:   LD   (__XChange_1+1), A
                DEC  A
                LD   (__XChange_2+1), A
                NEG
                LD   (__XChange_3+1), A
                RET


;======================== clear level routines =================





levelclear:
	ld	de,(20*256)+14
	ld	hl,(76*256)+48
	call	box
	ld	de,(21*256)+14
	ld	hl,(75*256)+20
	ld	c,1
	call	rectangle_filled
	ld	de,(14*256)+22
	ld	(pencol),de
	ld	hl,LEVELtitle
	set	textinverse,(iy+textflags)
	bcall(_vputs)
	res	textinverse,(iy+textflags)
	ld	de,(22*256)+28
	ld	(pencol),de
	ld	hl,LEVELtime
	bcall(_vputs)
	ld	hl,(leveltimer)
	call	dispvhl
	ld	hl,sectext
	bcall(_vputs)
	ld	de,(28*256)+31
	ld	(pencol),de
	ld	hl,LEVELmax
	bcall(_vputs)
	ld	hl,(level)
	ld	h,0			;hl=level
	ld	d,h
	ld	e,l			;de=hl
	add	hl,hl			;hl=hl*2
	add	hl,de			;hl=hl*3
	ld	de,37			;37 seconds initially
	add	hl,de			;hl=max amount of seconds for this level
	push	hl			;save max time
	call	dispvhl
	ld	hl,sectext
	bcall(_vputs)
	ld	de,(34*256)+32
	ld	(pencol),de
	ld	hl,LEVELpoints
	bcall(_vputs)
	pop	hl			;de=max time
	ld	de,(leveltimer)
	or	a
	sbc	hl,de			;hl=maxtime-leveltime (time left)
	bit	7,h			;if the result isnt negative
	jr	z,scorenofix		;don't fix hl
	ld	hl,0
scorenofix:
	ld	d,h
	ld	e,l
	add	hl,hl
	add	hl,hl
	add	hl,de			;hl=time left*5
	push	hl
	ex	de,hl
	call	addscore
	pop	hl
	call	dispvhl
	ld	de,(40*256)+28
	ld	(pencol),de
	ld	hl,LEVELscore
	bcall(_vputs)
	ld	hl,(score)
	call	dispvhl

	call	waitkc

;======================== shop routines =========================

shop:	ld	a,(mode)
	or	a
	jp	nz,shopd
	ld	a,(health)
	cp	96
	jr	z,shop1
	xor	a
	jr	shop2
shop1:	ld	a,1
shop2:	ld	(_a4),a
	call	centership
shopL:	call	clearGR
	ld	bc,(16*256)+2
	ld	l,47
	ld	a,40
	ld	ix,exitspr
	call	ionlargesprite
	ld	bc,(15*256)+2
	ld	l,0
	ld	a,40
	ld	ix,armorspr
	call	ionlargesprite
	ld	bc,(15*256)+2
	ld	l,24
	ld	a,1
	ld	ix,enginespr
	call	ionlargesprite
	ld	bc,(15*256)+2
	ld	l,24
	ld	a,96-16
	ld	ix,weaponspr
	call	ionlargesprite

	call	controlship
	call	moveship
	call	createshiptemptable
	call	putship
	call	puthealth

	xor	a
	ld	(tempy),a		;selection number

	ld	de,((40+8)*256)+47+8		;x,y
	call	checkshopcol
	jr	nc,shopd
	ld	de,((40+8)*256)+0+8
	call	checkshopcol
	jp	nc,shop_armor
	ld	de,((1+8)*256)+24+8
	call	checkshopcol
	jp	nc,shop_engine
	ld	de,((96-16+8)*256)+24+8
	call	checkshopcol
	jp	nc,shop_weapon

	ld	hl,0
	ld	(pencol),hl
	ld	hl,moneyspacer
	bcall(_vputs)
	ld	hl,(money)
	call	dispvhl
	call	ionfastcopy

	call	chkpause
	call	gamedelay		;delay game so it's at a constant speed
	jp	shopL			;loop back
shopd:	call	cleartables		;clear tables
	jp	load




shop_engine:
	ld	hl,menu_engine
	call	shop_domenu
	jp	nc,shop			;canceled
	cp	$ff
	jr	z,shop_engine
	or	a			;retroburner
	jr	z,buy_E_1
	dec	a
	jr	z,buy_E_2
	dec	a
	jr	z,buy_E_3
	dec	a
	jr	z,buy_E_4
	dec	a
	jr	z,buy_E_5
buy_E_6:
	ld	(_e6),a
	ld	a,8
	call	setturnspeed
	jp	shop_engine
buy_E_1:
	ld	hl,retrospeed1
	ld	(retrospeed),hl
	ld	(_e2),a			;enable retro lvl 2
	inc	a			;a=1
	ld	(retro),a
	ld	(_e1),a			;disable retro lvl 1
	jp	shop_engine
buy_E_2:
	ld	hl,retrospeed2
	ld	(retrospeed),hl
	ld	(_e1),a			;enable retro lvl 1
	inc	a
	ld	(retro),a		;a=1
	ld	(_e2),a			;disable retro lvl 2
	jp	shop_engine
buy_E_3:
	ld	(_e4),a
	ld	(_e5),a
	ld	(engine),a		;a=0
	inc	a
	ld	(_e3),a
	jp	shop_engine
buy_E_4:
	ld	(_e3),a
	ld	(_e5),a
	inc	a			;a=1
	ld	(engine),a
	ld	(_e4),a
	jp	shop_engine
buy_E_5:
	ld	(_e3),a
	ld	(_e4),a
	inc	a
	ld	(_e5),a
	inc	a
	ld	(engine),a
	jp	shop_engine


shop_weapon:
	ld	hl,menu_weapon
	call	shop_domenu
	jp	nc,shop			;if nc, user pressed cancel
	cp	$ff
	jr	z,shop_weapon
	or	a
	jr	z,buy_W_1
	dec	a
	jr	z,buy_W_2
	dec	a
	jr	z,buy_W_3
	dec	a
	jr	z,buy_W_4
	;dec	a
	;jr	z,buy_W_5
buy_W_5:
	ld	(_w5),a
	dec	a
	ld	(_w3),a
	ld	(_w4),a
	ld	a,16
	ld	(maxbullets),a
	jp	shop_weapon
buy_W_1:
	ld	(rapidfiretimer),a	;rapidfiretimer=0
	inc	a			;a=1
	ld	(_w1),a
	ld	(rapidfire),a		;you have rapidfire!
	jp	shop_weapon
buy_W_2:
	inc	a
	ld	(_w2),a
	ld	(doubleshot),a
	ld	(doubleEnable),a	;turn on doubleshot
	jp	shop_weapon
buy_w_3:
	ld	(_w4),a
	ld	(_w5),a
	inc	a
	ld	(_w3),a
	ld	a,8
	ld	(maxbullets),a
	jp	shop_weapon
buy_W_4:
	ld	(_w3),a
	ld	(_w5),a
	inc	a
	ld	(_w4),a
	ld	a,12
	ld	(maxbullets),a
	jp	shop_weapon


shop_armor:
	ld	hl,menu_armor
	call	shop_domenu
	jp	nc,shop
	cp	$ff
	jr	z,shop_armor
	or	a
	jr	z,buy_A_1
	dec	a
	jr	z,buy_A_2
	dec	a
	jr	z,buy_A_3
	dec	a
	jr	z,buy_A_4
buy_A_5:
	ld	(regen),a		;regen=true
	ld	(regenflag),a		;regenflag = 1
	ld	a,(regentotal)
	add	a,regenduration
	jr	nc,buy_A_5b
	ld	a,255
buy_A_5b:
	ld	(regentotal),a
	jp	shop_armor
buy_A_1:
	ld	(_a2),a
	ld	(_a3),a
	inc	a			;a=1
	ld	(_a1),a
	ld	(armor),a
	jp	shop_armor
buy_A_2:
	ld	(_a1),a
	ld	(_a3),a
	inc	a
	ld	(_a2),a
	inc	a
	ld	(armor),a
	jp	shop_armor
buy_A_3:
	ld	(_a1),a
	ld	(_a2),a
	inc	a
	ld	(_a3),a
	ld	a,3
	ld	(armor),a
	jp	shop_armor
buy_A_4:
;	call	getdamage
;	add	a,(hl)			;a=new health
;	cp	95
;	jr	nc,buy_a_4b		;if health is greater than 96
	ld	a,1
	ld	(_a4),a
	ld	a,96
;buy_a_4b:
	ld	(health),a		;full health
	call	puthealth
	jp	shop_armor



;d=xcoord
;e=ycoord
checkshopcol:
	ld	hl,shiptemptable
	ld	b,6
	ld	a,d
	ld	(_chk1+1),a
	add	a,15
	ld	(_chk2+1),a
	ld	a,e
	ld	(_chk3+1),a
	add	a,15
	ld	(_chk4+1),a
chkshL:	ld	a,(hl)			;a=xcoord
_chk1:	cp	0			;compare it to the left side
	jr	c,chkdj1
_chk2:	cp	0			;compare it to the right side
	jr	nc,chkdj1		;
	inc	hl
	ld	a,(hl)
_chk3:	cp	0			;compare it to the top
	jr	c,chkdj2
_chk4:	cp	0
	jr	nc,chkdj2
	or	a			;nc
	ret
chkdj1:	inc	hl
chkdj2:	inc	hl
	djnz	chkshl
	scf				;c
	ret




shop_domenu:
	push	hl
	push	hl
	ld	de,(5*256)+5
	ld	hl,(91*256)+59
	call	box
	ld	de,(6*256)+6
	ld	hl,(90*256)+6+5
	ld	c,1
	call	Rectangle_Filled

	set	textinverse,(iy+textflags)
	ld	de,(5*256)+6
	ld	(pencol),de
	ld	hl,moneyspacer
	bcall(_vputs)
	ld	hl,(money)
	call	dispvhl
	pop	hl
	ld	a,5
	ld	(penrow),a
	ld	a,(hl)
	ld	(pencol),a
	inc	hl
	bcall(_vputs)
	res	textinverse,(iy+textflags)
	ld	b,(hl)
	inc	hl
	ld	a,6+7
	ld	(penrow),a
	push	bc
shop_drawmenuL:
	push	bc
	push	hl
	ld	a,(hl)
	add	a,a
	add	a,a			;a=a*4
	add	a,(hl)			;a=a*5
	ld	e,a
	ld	d,0
	ld	ix,menuchkspr
	add	ix,de			;ix points to the right sprite
	ld	hl,(penrow)		;l=ycoord
	inc	l
	ld	a,7
	ld	b,5
	call	ionputsprite
	pop	hl
	inc	hl			;past status
	push	hl
	ld	a,7+7
	ld	(pencol),a
	ld	e,(hl)
	inc	hl
	ld	d,(hl)			;de=(hl)
	call	bintobcd16
	ld	hl,bcd16string
	bcall(_vputs)
	ld	hl,menu_spacer
	bcall(_vputs)
	pop	hl
	inc	hl			
	inc	hl			;past cost
	inc	hl			;past center pos.
	bcall(_vputs)
	ld	a,(penrow)
	add	a,6
	ld	(penrow),a
	pop	bc
	djnz	shop_drawmenuL
	ld	a,7
	ld	(pencol),a
	ld	hl,menu_cancel
	bcall(_vputs)
	pop	bc		;b=how many cols there are
	ld	a,b
	ld	(tempx),a		;store this here..
	call	menu_cursor
	call	getkdh
sh_cpy:	call	ionfastcopy
shop_domenuK:
	call	getkdhd
	bit	3,b
	jr	z,shop_domenu_up
	bit	0,b
	jr	z,shop_domenu_down
	bit	7,b
	jr	z,shop_select
	jr	shop_domenuK

shop_domenu_up:
	call	menu_cursor
	ld	a,(tempy)
	or	a
	jr	z,shop_domenu_up_d
	dec	a
shop_domenu_up_d:
	ld	(tempy),a
	call	menu_cursor
	jr	sh_cpy


shop_domenu_down:
	call	menu_cursor
	ld	a,(tempy)
	ld	bc,(tempx)
	cp	c
	jr	z,shop_domenu_down_d
	inc	a
shop_domenu_down_d:
	ld	(tempy),a
	call	menu_cursor
	jr	sh_cpy
shop_select:
	ld	a,(tempy)
	pop	hl
	ld	bc,(tempx)
	cp	c
	ret	z			;cancel.. don't confirm (sets nc)
	call	shop_confirm
	ret	nc			;canceled the confirm
	scf				;return and confirm, set carry
	ret



;hl points to the menu data
;a is the selection
shop_confirm:
	call	next0			;past shop title
	inc	hl			;past number of rows
shop_confirmL:
	or	a
	jr	z,shop_confirm_draw
	inc	hl			;go past status
	inc	hl
	inc	hl			;go past cost
	call	next0			;find next string
	dec	a
	jr	shop_confirmL
shop_confirm_draw:
	ld	a,(hl)
	or	a
	jp	nz,shop_confirm_HAVE	;you already have this!
	inc	hl
	push	hl			;save pointer to cost
	inc	hl
	inc	hl			;hl points to the string
	push	hl
	ld	de,(10*256)+20
	ld	hl,(86*256)+44
	call	box
	ld	de,(10*256)+20
	ld	hl,(86*256)+20+6
	ld	c,1
	call	Rectangle_Filled
	pop	hl
	ld	e,(hl)
	inc	hl
	ld	d,20
	ld	(pencol),de
	set	textinverse,(iy+textflags)
	bcall(_vputs)
	res	textinverse,(iy+textflags)
	ld	de,((20+7)*256)+38
	ld	(pencol),de
	ld	hl,moneyspacer
	bcall(_vputs)
	pop	hl			;hl points to the cost
	ld	e,(hl)
	inc	hl
	ld	d,(hl)			;de = cost
	ld	(_hlfix+1),de		;save de
	call	bintobcd16
	ld	hl,bcd16string
	bcall(_vputs)
	ld	de,((20+7+7)*256)+35
	ld	(pencol),de
	ld	hl,confirm_text
	bcall(_vputs)
	ld	a,34
confirmKL:
	ld	(op1),a			;temp storage space
	call	confirmput		;display selector
	call	ionfastcopy
	call	confirmput		;erase selector
confirmK:
	call	getkdh
	bit	7,b
	jr	z,confirmselect
	bit	1,b
	jr	z,confirmleft
	bit	2,b
	jr	z,confirmright
	jr	confirmK

confirmleft:
	ld	a,34
	jr	confirmKL
confirmright:
	ld	a,48
	jr	confirmKL

confirmput:
	ld	de,(op1-1)		;d=x
	ld	a,d
	add	a,11
	ld	h,a
	ld	e,20+7+7
	ld	l,20+7+7+6
	ld	c,2
	jp	rectangle_filled

confirmselect:
	ld	a,(op1)
	cp	48
	scf
	ld	a,$ff
	ret	z			;chose no
_hlfix:	ld	de,0			;de=cost
	ld	hl,(money)		;hl=money
	bcall(_cphlde)			;compare them
	jr	c,confirmpoor		;not enough money!
	sbc	hl,de			;carry was already reset from _cphlde
	ld	(money),hl		;save new money!
	ld	de,(33*256)+28
	ld	hl,(62*256)+36
	call	box
	ld	de,(29*256)+36
	ld	(pencol),de
	ld	hl,boughttxt
	bcall(_vputs)
	call	waitkC
	ld	a,(tempy)
	scf				;return with c
	ret
confirmpoor:
	ld	de,(15*256)+28
	ld	hl,(81*256)+36
	call	box
	ld	de,(29*256)+21
	ld	(pencol),de
	ld	hl,poortxt
cret:	bcall(_vputs)
	call	waitkC
	ld	a,$ff			;don't return to shop
	scf
	ret
shop_confirm_HAVE:
	ld	de,(10*256)+28
	ld	hl,(86*256)+36
	call	box
	ld	de,(29*256)+12
	ld	(pencol),de
	ld	hl,havetxt
	jr	cret



next0:
	push	af
	xor	a			;look for a zero
	ld	bc,100			;look through 100 bytes	max
	cpir				;find zero
	pop	af
	ret





;cursor row=(tempy)
menu_cursor:
	ld	a,(tempy)
	ld	b,a
	add	a,a			;*2
	add	a,b			;*3
	add	a,a			;*6
	add	a,13			;screen y offset
	ld	d,6
	ld	e,a
	ld	h,90
	add	a,6
	ld	l,a
	ld	c,2
	jp	rectangle_filled





;======================= end of shop routines ===================





;=======================================;
; Horizontal and Verticle Line Routines ;
; By Jason Kovacs & The TCPA - 10/11/99 ;
;=======================================;

; For H_Line and V_Line:
;
; Input:  B = Length of Line (Number of Pixels)
;         C = Color of Line (0-White, 1-Black, 2-XORed)
;         D = X Coordinate Start of the Line
;         E = Y Coordinate Start of the Line
;
; Output: Lines are Drawn to the Graph Buffer, and the Starting
;    Byte and Pixel Mask are Automatically determined according
;    to the Input of the Coordinates in DE.
;
; Registers Affected:  All Registers are Preserved Except AF.

V_Line:
        push de
        push hl
        push bc
        ld a, d
        call Getpix
        pop bc
        push bc
        ld d, c
        ld c, a
        ld a, d
        ld de, 12
        or a
        call z, V_White_Line
        dec a
        call z, V_Black_Line
        dec a
        call z, V_XORed_Line
        pop bc
        pop hl
        pop de
        ret

V_White_Line:
        ld a, c
        CPL
        ld c, a 
V_White_Line_2:
        ld a, (hl)
        and c
        ld (hl), a
        add hl, de
        DJNZ V_White_Line_2
        xor a
        ret

V_Black_Line:
        ld a, (hl)
        or c
        ld (hl), a
        add hl, de
        DJNZ V_Black_Line
        xor a
        ret

V_XORed_Line:
        ld a, (hl)
        xor c
        ld (hl), a
        add hl, de
        DJNZ V_XORed_Line
        ret

H_Line:
        push de
        push hl
        push bc
        ld a, d
        call Getpix
        pop bc
        push bc
        ld d, c
        ld c, a
        ld a, d
        or a
        call z, H_White_Line
        dec a
        call z, H_Black_Line
        dec a
        call z, H_XORed_Line
        pop bc
        pop hl
        pop de
        ret

H_White_Line:
        ld a, c
        CPL
        ld c, a
H_White_Line_2:
        ld a, (hl)
        and c
        ld (hl), a
        RR c
        jr c, Cont_H_White_Line 
        inc hl
        RR c
Cont_H_White_Line:
        DJNZ H_White_Line
        xor a
        ret

H_Black_Line:
        ld a, (hl)
        or c
        ld (hl), a
        RR c
        jr nc, Cont_H_Black_Line
        inc hl
        RR c
Cont_H_Black_Line:
        DJNZ H_Black_Line
        xor a
        ret

H_XORed_Line:
        ld a, (hl)
        xor c
        ld (hl), a
        RR c
        jr nc, Cont_H_XORed_Line
        inc hl
        RR c
Cont_H_XORed_Line:
        DJNZ H_XORed_Line
        ret

Getpix: ld d, 0
        ld h, d
        ld l, e
        add hl, de
        add hl, de
        add hl, hl
        add hl, hl
        ld de, Plotsscreen
        add hl, de
Getbit: ld b, 0
        ld c, a
        and %00000111
        srl c
        srl c
        srl c
        add hl, bc
        ld b, a
        inc b
        ld a, %00000001
GBLoop: RRCA
        djnz GBLoop
        ret

;=======================================;
; Rectangle Filling Routine Version 1.0 ;
; By Jason Kovacs & The TCPA - 10/11/99 ;
;=======================================;

; Input:  D = Top Left X Coordinate, E = Top Left Y Coordinate
;         H = Bottom Right X Coord,  L = Bottom Right Y Coord
;         C = Color of Lines (0-White, 1-Black, 2-XORed)
;
; Output: A Rectangle is drawn to the Graph Buffer with its border
;    and everything within it Filled in according to the value in
;    reg C which specifies the Color.
;
; Registers Affected: AF Destroyed; B=0 ; C, DE, HL Preserved.
;    The Index Registers and the Shadow Registers Aren't Used.
putmenu:
	ld	de,(curcol)		;e=ycoord
	ld	a,e
	add	a,6
	ld	l,a
	ld	d,17
	ld	h,77
	ld	c,2
	jr	rectangle_filled




;hl,de
box:	ld	c,1
	push	de
	push	hl
	call	rectangle_outline
	pop	hl
	pop	de
	inc	d
	inc	e
	push	de
	push	hl
	inc	h
	inc	l
	ld	c,1
	call	rectangle_outline

	pop	hl
	pop	de
	dec	h
	dec	l
	ld	c,0


Rectangle_Filled:
        ld	a, l
        sub	e
        inc	a
        ld	b, a
        ld	a, h
        sub	d
        inc	a   
        push	de
Rect_Fill_Loop:
        push	af
        call	V_Line
        pop	af
        inc	d
        dec	a
        jr	nz, Rect_Fill_Loop
        pop	de
        ret

;=======================================;
; Rectangle Outline Routine Version 1.0 ;
; By Jason Kovacs & The TCPA - 10/11/99 ;
;=======================================;

; Input:  D = Top Left X Coordinate, E = Top Left Y Coordinate
;         H = Bottom Right X Coord,  L = Bottom Right Y Coord
;         C = Color of Lines (0-White, 1-Black, 2-XORed)
;
; Output: The Border of a Rectangle is drawn to the Graph Buffer,
;    and the inside of it is unaffected. The Color of the Lines
;    of the Rectangle Outline depend on the value in Register C.
;
; Registers Affected: AF Destroyed; B=0 ; C, DE, HL Preserved.
;    The Index Registers and the Shadow Registers Aren't Used.

Rectangle_Outline:
        ld	a, l
        sub	e
        inc	a
        ld	b, a
        call	V_Line
        push	de
        ld	d, h
        call	V_Line     
        pop	de
        ld	a, h
        sub	d
        dec	a
        ld	b, a
        inc	d
        call	H_Line
        push	de
        ld	e, l
        call	H_Line
        pop	de
        ret

;NOTES: These Line and Rectangle Routines have the GETPIX and GETBIT
;       routines, from the ZLIB Library, incorporated into the code.
;       Thanks go to Joe Wingbermuehle for creating those routines,
;       and letting me use them. Visit his site at "joewing.calc.org".
;       Thanks also goto Dan Englender and Scott Dial for encouraging
;       me to improve and optimize those crap routines I released to
;       the TCPA a few months ago. Our Webpage is at "tcpa.calc.org".
;       These routines have been thoroughly tested, but if there are
;       still any bugs, mail them to me at Jason_K@calc.org. I would
;       appreciate if you gave credit to me, if you use these routines
;       in your program, or just keep this file intact when you paste
;       them into your code.
;
;       Copyright (c) 1999 - TI-Calculator Programming Alliance [TCPA]






interrupt_start:
	ex	af,af'
	ld	a,(timecounter)
	inc	a
	ld	(timecounter),a
	ex	af,af'
	jp	$0038

interrupt_end:

quit:	res	textwrite,(iy+sgrflags)
	im	1
	ret





shopspr:
exitspr:
	.db %01000000,%00000010
	.db %10111111,%11111101
	.db %10111111,%11111101
	.db %10111111,%11111101
	.db %10111111,%11111101
	.db %10111111,%11111101
	.db %10111111,%11111101
	.db %10011111,%11111001
	.db %10000000,%00000001
	.db %10110101,%01011101
	.db %10100101,%01001001
	.db %10110010,%01001001
	.db %10100101,%01001001
	.db %10110101,%01001001
	.db %10000000,%00000001
	.db %01111111,%11111110
armorspr:
	.db %00111111,%11111110
	.db %01000000,%00000001
	.db %01001100,%00011001
	.db %01001011,%11101001
	.db %01001000,%10001001
	.db %01001000,%10001001
	.db %01001100,%10011001
	.db %01001011,%11101001
	.db %01001000,%10001001
	.db %01001000,%10001001
	.db %01000100,%10010001
	.db %01000010,%10100001
	.db %01000001,%11000001
	.db %01000000,%00000001
	.db %00111111,%11111110
enginespr:
	.db %01111111,%11111100
	.db %10000000,%00000010
	.db %10000000,%00000010
	.db %10000000,%00011010
	.db %10000000,%01101010
	.db %10000011,%10010010
	.db %10000010,%00010010
	.db %10000001,%00100010
	.db %10001000,%10100010
	.db %10010010,%01100010
	.db %10000100,%00000010
	.db %10001001,%00000010
	.db %10010010,%00000010
	.db %10000000,%00000010
	.db %01111111,%11111100
weaponspr:
	.db %01111111,%11111100
	.db %10000000,%00000010
	.db %10000000,%00111010
	.db %10000000,%01001010
	.db %10000000,%10011010
	.db %10000001,%00110010
	.db %10000010,%01100010
	.db %10000100,%11000010
	.db %10011001,%10000010
	.db %10001011,%00000010
	.db %10011110,%00000010
	.db %10111010,%00000010
	.db %10110000,%00000010
	.db %10000000,%00000010
	.db %01111111,%11111100

menuchkspr:
	.db %01110000
	.db %10001000
	.db %10001000
	.db %10001000
	.db %01110000

	.db %01110000
	.db %11111000
	.db %11111000
	.db %11111000
	.db %01110000



titlespr:
	.db %00010000,%01111011,%11111011,%11100111,%10001111,%00011111,%01111000,%00111100
	.db %00101000,%10000000,%01000010,%00000100,%01001001,%00000100,%01000100,%01000000
	.db %00101000,%10000000,%01000010,%00000100,%01010000,%10000100,%01000010,%01000000
	.db %00101000,%01100000,%01000010,%00000100,%10010000,%10000100,%01000010,%00110000
	.db %01000100,%00010000,%01000011,%11000111,%00010000,%10000100,%01000010,%00001000
	.db %01111100,%00001000,%01000010,%00000101,%00010000,%10000100,%01000010,%00000100
	.db %01000100,%00001000,%01000010,%00000100,%10001001,%00000100,%01000100,%00000100
	.db %10000010,%11110000,%01000011,%11100100,%01001111,%00011111,%01111000,%01111000

enterspr:
	.db %11011110,%10001011,%11101111,%01111011
	.db %10010000,%11001000,%10001000,%01001001
	.db %10011110,%10101000,%10001111,%01111001
	.db %10010000,%10011000,%10001000,%01010001
	.db %11011110,%10001000,%10001111,%01001011




shipspr:
	.db %00010000
	.db %00010000
	.db %00101000
	.db %00101000
	.db %01000100
	.db %01000100
	.db %10000010
	.db %11111110

	.db %00000100
	.db %00001100
	.db %00010100
	.db %00100100
	.db %01000010
	.db %10000010
	.db %11110010
	.db %00001110

	.db %00000010
	.db %00000110
	.db %00001010
	.db %00010010
	.db %00100010
	.db %01000010
	.db %01110010
	.db %00001110

	.db %00000000
	.db %00000110
	.db %00011010
	.db %01100010
	.db %10000100
	.db %11000100
	.db %00100100
	.db %00011100

	.db %00000000
	.db %00000110
	.db %00011010
	.db %11100100
	.db %10000100
	.db %01001000
	.db %00101000
	.db %00011000

	.db %00000000
	.db %00001110
	.db %11110010
	.db %10000100
	.db %10000100
	.db %01001000
	.db %00101000
	.db %00110000

	.db %00000000
	.db %11111111
	.db %10000010
	.db %10000100
	.db %01001000
	.db %01010000
	.db %01100000
	.db %00000000

	.db %00000000
	.db %11110000
	.db %10001111
	.db %10000010
	.db %01000100
	.db %01001000
	.db %01010000
	.db %01100000


;90 degrees

	.db %11000000
	.db %10110000
	.db %10001100
	.db %10000011
	.db %10001100
	.db %10110000
	.db %11000000
	.db %00000000

	.db %01100000
	.db %01010000
	.db %01001000
	.db %01000100
	.db %10000010
	.db %10001111
	.db %11110000
	.db %00000000

	.db %00000000
	.db %01100000
	.db %01010000
	.db %01001000
	.db %10000100
	.db %10000010
	.db %11111111
	.db %00000000

	.db %00110000
	.db %00101000
	.db %01001000
	.db %10000100
	.db %10000100
	.db %11110010
	.db %00001110
	.db %00000000

	.db %00011000
	.db %00101000
	.db %01001000
	.db %10000100
	.db %11100100
	.db %00011010
	.db %00000110
	.db %00000000

	.db %00011100
	.db %00100100
	.db %11000100
	.db %10000100
	.db %01100010
	.db %00011010
	.db %00000110
	.db %00000000

	.db %00001110
	.db %01110010
	.db %01000010
	.db %00100010
	.db %00010010
	.db %00001010
	.db %00000110
	.db %00000010

	.db %00000111
	.db %01111001
	.db %01000001
	.db %00100001
	.db %00010010
	.db %00001010
	.db %00000110
	.db %00000010


;180 degrees

	.db %01111111
	.db %01000001
	.db %00100010
	.db %00100010
	.db %00010100
	.db %00010100
	.db %00001000
	.db %00001000

	.db %01110000
	.db %01001111
	.db %01000001
	.db %01000010
	.db %00100100
	.db %00101000
	.db %00110000
	.db %00100000

	.db %01110000
	.db %01001110
	.db %01000010
	.db %01000100
	.db %01001000
	.db %01010000
	.db %01100000
	.db %01000000

	.db %00111000
	.db %00100100
	.db %00100011
	.db %00100001
	.db %01000110
	.db %01011000
	.db %01100000
	.db %00000000

	.db %00011000
	.db %00010100
	.db %00010010
	.db %00100001
	.db %00100111
	.db %01011000
	.db %01100000
	.db %00000000

	.db %00001100
	.db %00010100
	.db %00010010
	.db %00100001
	.db %00100001
	.db %01001111
	.db %01110000
	.db %00000000

	.db %00000000
	.db %00000110
	.db %00001010
	.db %00010010
	.db %00100001
	.db %01000001
	.db %11111111
	.db %00000000

	.db %00000000
	.db %00000110
	.db %00001010
	.db %00010010
	.db %00100010
	.db %01000001
	.db %11110001
	.db %00001111


;270 degrees

	.db %00000000
	.db %00000011
	.db %00001101
	.db %00110001
	.db %11000001
	.db %00110001
	.db %00001101
	.db %00000011

	.db %00000000
	.db %00001111
	.db %11110001
	.db %01000001
	.db %00100010
	.db %00010010
	.db %00001010
	.db %00000110

	.db %00000000
	.db %11111111
	.db %01000001
	.db %00100001
	.db %00010010
	.db %00001010
	.db %00000110
	.db %00000000

	.db %00000000
	.db %01110000
	.db %01001111
	.db %00100001
	.db %00100001
	.db %00010010
	.db %00010100
	.db %00001100

	.db %00000000
	.db %01100000
	.db %01011000
	.db %00100111
	.db %00100001
	.db %00010010
	.db %00010100
	.db %00011000

	.db %00000000
	.db %01100000
	.db %01011000
	.db %01000110
	.db %00100001
	.db %00100011
	.db %00100100
	.db %00111000

	.db %01000000
	.db %01100000
	.db %01010000
	.db %01001000
	.db %01000100
	.db %01000010
	.db %01001110
	.db %01110000

	.db %00100000
	.db %00110000
	.db %00101000
	.db %00100100
	.db %01000010
	.db %01000001
	.db %01001111
	.db %01110000

asteroidsprites:
	.db %01111000
	.db %11110110
	.db %10110111
	.db %11111011
	.db %01111111
	.db %11011011
	.db %11001110
	.db %01111100

	.db %00011000
	.db %01101100
	.db %11011100
	.db %11110100
	.db %01011100
	.db %00111000
	.db %00000000
	.db %00000000

	.db %00000000
	.db %00110000
	.db %01101000
	.db %01111000
	.db %00110000
	.db %00000000
	.db %00000000
	.db %00000000

	.db %00111000
	.db %01010100
	.db %01010000
	.db %00111000
	.db %00010100
	.db %01010100
	.db %00111000
	.db %00000000

	.db %01101100
	.db %11111110
	.db %11111110
	.db %01111100
	.db %00111000
	.db %00010000
	.db %00000000
	.db %00000000


explosionspr:
	.db %00000000
	.db %00000000
	.db %00010000
	.db %00111100
	.db %00101000
	.db %00011000
	.db %00000000
	.db %00000000

	.db %00000000
	.db %00010000
	.db %00101110
	.db %01011110
	.db %01111010
	.db %00111100
	.db %00001000
	.db %00000000

	.db %00000000
	.db %00111010
	.db %01110101
	.db %01011110
	.db %11111010
	.db %00111101
	.db %01110100
	.db %00000000

	.db %00111100
	.db %11110111
	.db %01111101
	.db %11101110
	.db %01111110
	.db %01101111
	.db %10111010
	.db %00111100

;this stuff could be compressed, but I didn't bother
;
bullet_entry_table:
	.db 3,0
	.db 5,0
	.db 6,0
	.db 6,0
	.db 6,1
	.db 7,1
	.db 7,1
	.db 7,2
	.db 7,3
	.db 7,5
	.db 7,6
	.db 7,6
	.db 6,6
	.db 6,7
	.db 6,7
	.db 6,7
	.db 4,7
	.db 2,7
	.db 1,7
	.db 1,7
	.db 1,6
	.db 0,6
	.db 0,6
	.db 0,6
	.db 0,3
	.db 0,2
	.db 0,1
	.db 0,1
	.db 1,1
	.db 1,0
	.db 1,0
	.db 2,0

ship_col_table:
	.db 3,0		;collision pixel offsets
	.db 0,7		;from most to least likely
	.db 6,7		;(x,y)
	.db 2,4
	.db 4,4
	.db 3,7

	.db 5,0
	.db 0,6
	.db 6,7
	.db 2,2
	.db 6,4
	.db 3,6

	.db 6,0
	.db 1,6
	.db 6,7
	.db 3,6
	.db 3,3
	.db 6,4

	.db 6,1
	.db 0,5
	.db 5,7
	.db 3,2
	.db 5,4
	.db 2,6

	.db 6,1
	.db 0,3
	.db 4,7
	.db 3,2
	.db 5,4
	.db 2,5

	.db 6,1
	.db 0,2
	.db 3,7
	.db 3,2
	.db 5,3
	.db 1,5

	.db 7,1
	.db 0,1
	.db 1,6
	.db 3,1
	.db 4,4
	.db 1,4

	.db 7,2
	.db 0,1
	.db 1,7
	.db 3,1
	.db 4,5
	.db 1,4

	.db 7,3		;90 degrees
	.db 0,0
	.db 0,6
	.db 3,2
	.db 3,4
	.db 0,3

	.db 7,5
	.db 1,0
	.db 0,6
	.db 4,2
	.db 4,4
	.db 1,3

	.db 7,6
	.db 1,1
	.db 0,6
	.db 4,3
	.db 3,6
	.db 1,3

	.db 6,6
	.db 3,0
	.db 0,5
	.db 4,2
	.db 3,5
	.db 1,2

	.db 6,6
	.db 4,0
	.db 0,4
	.db 5,3
	.db 3,5
	.db 2,2

	.db 6,6
	.db 5,0
	.db 0,3
	.db 5,3
	.db 3,5
	.db 2,1

	.db 6,7
	.db 1,1
	.db 6,0
	.db 6,3
	.db 3,4
	.db 3,1

	.db 6,7
	.db 7,0
	.db 1,1
	.db 3,4
	.db 7,3
	.db 5,1

	.db 4,7		;180
	.db 1,0
	.db 7,0
	.db 3,3
	.db 5,3
	.db 4,0

	.db 2,7
	.db 1,0
	.db 7,1
	.db 1,3
	.db 5,4
	.db 4,1

	.db 1,7
	.db 1,0
	.db 6,1
	.db 1,3
	.db 4,4
	.db 4,1

	.db 1,6
	.db 2,0
	.db 7,3
	.db 2,3
	.db 4,5
	.db 5,1

	.db 1,6
	.db 3,0
	.db 7,4
	.db 2,3
	.db 4,5
	.db 5,2

	.db 1,6
	.db 4,0
	.db 7,5
	.db 2,3
	.db 4,5
	.db 6,2

	.db 0,6
	.db 6,1
	.db 7,6
	.db 3,3
	.db 4,6
	.db 6,3

	.db 0,6
	.db 6,1
	.db 7,7
	.db 3,3
	.db 4,7
	.db 6,4

	.db 0,3		;270
	.db 7,0
	.db 7,6
	.db 4,2
	.db 4,4
	.db 7,3

	.db 0,2
	.db 7,1
	.db 6,7
	.db 3,5
	.db 4,1
	.db 6,4

	.db 0,1
	.db 7,1
	.db 6,6
	.db 4,1
	.db 3,4
	.db 6,4

	.db 1,1
	.db 7,2
	.db 4,7
	.db 4,2
	.db 3,5
	.db 6,5

	.db 1,1
	.db 7,3
	.db 3,7
	.db 4,2
	.db 2,4
	.db 5,5

	.db 1,1
	.db 2,7
	.db 7,5
	.db 4,2
	.db 2,4
	.db 5,6

	.db 1,0
	.db 1,7
	.db 6,6
	.db 1,4
	.db 4,3
	.db 4,6

	.db 2,0
	.db 7,6
	.db 1,7
	.db 1,4
	.db 5,3
	.db 4,6

;cosine lookup table for finding the direction/speed of
;a bullet being fired
;
bullet_velocity:
	.dw 0
	.dw 117
	.dw 229
	.dw 333
	.dw 424
	.dw 498
	.dw 554
	.dw 588
	.dw 600
	.dw 588
	.dw 554
	.dw 498
	.dw 424
	.dw 333
	.dw 229
	.dw 117
	.dw 0
	.dw -117
	.dw -229
	.dw -333
	.dw -424
	.dw -498
	.dw -554
	.dw -588
	.dw -600
	.dw -588
	.dw -554
	.dw -498
	.dw -424
	.dw -333
	.dw -229
	.dw -117


shotspr:
	.db %11000000
	.db %11000000

;the following are 6 sine/cosine lookup tables for
;finding which direction to thrust in
;
velocitytables:
velocitytable1:
	.dw -8
	.dw -7
	.dw -6
	.dw -5
	.dw -4
	.dw -3
	.dw -2
	.dw -1
	.dw 0
	.dw 1
	.dw 2
	.dw 3
	.dw 4
	.dw 5
	.dw 6
	.dw 7
	.dw 8
	.dw 7
	.dw 6
	.dw 5
	.dw 4
	.dw 3
	.dw 2
	.dw 1
	.dw 0
	.dw -1
	.dw -2
	.dw -3
	.dw -4
	.dw -5
	.dw -6
	.dw -7

velocitytable2:
	.dw -16
	.dw -15
	.dw -14
	.dw -13
	.dw -11
	.dw -9
	.dw -6
	.dw -3
	.dw 0
	.dw 3
	.dw 6
	.dw 9
	.dw 11
	.dw 13
	.dw 14
	.dw 15
	.dw 16
	.dw 15
	.dw 14
	.dw 13
	.dw 11
	.dw 9
	.dw 6
	.dw 3
	.dw 0
	.dw -3
	.dw -6
	.dw -9
	.dw -11
	.dw -13
	.dw -14
	.dw -15

velocitytable3:
	.dw -24
	.dw -23
	.dw -22
	.dw -19
	.dw -16
	.dw -13
	.dw -9
	.dw -4
	.dw 0
	.dw 4
	.dw 9
	.dw 13
	.dw 16
	.dw 19
	.dw 22
	.dw 23
	.dw 24
	.dw 23
	.dw 22
	.dw 19
	.dw 16
	.dw 13
	.dw 9
	.dw 4
	.dw 0
	.dw -4
	.dw -9
	.dw -13
	.dw -16
	.dw -19
	.dw -22
	.dw -23


armortable:		;table for how much damage you recieve depending on which armor you have
	.db 16		;no armor - 16 damage/asteroid
	.db 12		;armor lvl 1 - 12 damage/asteroid
	.db 10		;etc.
	.db 8		;

	.db 20
	.db 16
	.db 13
	.db 10

	.db 24
	.db 20
	.db 17
	.db 12
moneytable:
	.db 100
	.db 75
	.db 50


menui: 	.dw _e1
	.dw _e2
	.dw _e3
	.dw _e4
	.dw _e5
	.dw _e6
	.dw _a1
	.dw _a2
	.dw _a3
	.dw _a4
	.dw _a5
	.dw _w1
	.dw _w2
	.dw _w3
	.dw _w4
	.dw _w5



lvltxt:	.db "Level:",0
pausedtxt:
	.db "Paused - ",0
conttxt:
	.db "Cont",0
quittxt:
	.db "Quit",0
engineshop:
	.db "Engine Shop",0
armorshop:
	.db "Armor Shop",0
LEVELtitle:
	.db " Level Complete ",0
LEVELtime:
	.db "Time:",0
LEVELmax:
	.db "Max: ",0
LEVELpoints:
	.db "Points:",0
LEVELscore:
	.db "Score:",0
sectext:
	.db " sec.",0



menu_cancel:
	.db "Cancel",0
menu_spacer:
	.db " - ",0
moneyspacer:
	.db "$",0
confirm_text:
	.db "Yes    No",0

poortxt:
	.db "Not enough cash!",0
boughttxt:
	.db "Bought!",0
havetxt:
	.db "You already have this!",0
;deathtxt:
;	.db "You died!",0
livestxt:
	.db " lives",0

start_menu:
	.db "Play Asteroids",0
	.db "Options",0
	.db "Hiscores",0
	.db "Quit",0

hiscoretxt:
	.db "Easy:",0
	.db "Medium:",0
	.db "Hard:",0
	.db $C1,"CLEAR] to Reset",0
dificultytxt:
	.db 35,$cf," Easy  ",$05,0
	.db 31,$cf," Medium ",$05,0
	.db 35,$cf," Hard ",$05,0
modetxt:
	.db 28,$1e," Enhanced ",$1f,0
	.db 32,$1e," Classic ",$1f,0

dificulty:
	.db 0
mode:	.db 0
hiscores:
	.dw 0
	.dw 0
	.dw 0

	.dw 0
	.dw 0
	.dw 0

gethiscore:
	.db "Hiscore!",0

tempx:	.db 0
tempy	.db 0


menu_engine:
	.db 30,"Engine Store",0
	.db 6				;6 items

_e1:	.db 0				;status (if you have it or not)
	.dw 250				;price
	.db 19,"RetroBurner lvl 1",0	;name
_e2:	.db 0
	.dw 400
	.db 19,"RetroBurner lvl 2",0
_e3:	.db 1				;you start with this engine
	.dw 100
	.db 27,"Small Engine",0
_e4:	.db 0
	.dw 400
	.db 26,"Medium Engine",0
_e5:	.db 0
	.dw 850
	.db 26,"Large Engine",0
_e6:	.db 0
	.dw 550
	.db 27,"Fast Turning",0

menu_armor:
	.db 32,"Armor Store",0
	.db 5

_a1:	.db 0
	.dw 250
	.db 32,"Weak Armor",0
_a2:	.db 0
	.dw 500
	.db 27,"Medium Armor",0
_a3:	.db 0
	.dw 1000
	.db 27,"Strong Armor",0
_a4:	.db 0
	.dw 200
	.db 31,"Repair Ship",0
_a5:	.db 0
	.dw 350
	.db 28,"Shield Regen",0
menu_weapon:
	.db 29,"Weapon Store",0
	.db 5

_w1:	.db 0
	.dw 800
	.db 32,"Rapid Fire",0
_w2:	.db 0
	.dw 900
	.db 29,"Double Shot",0
_w3:	.db 0
	.dw 200
	.db 35,"8 Bullets",0
_w4:	.db 0
	.dw 400
	.db 35,"12 Bullets",0
_w5:	.db 0
	.dw 700
	.db 35,"16 Bullets",0
url:	.db "tiworld.calc.org",0
.end
END

