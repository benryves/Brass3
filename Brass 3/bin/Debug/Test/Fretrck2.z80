;+====================================================================================================+
;|                                 ____________________________________                               |
;|                                / _____   __   ____      _____      /\  A 'calc83plus'              |
;|                               / / ___/\ / /\ / __ \    / ___/\    / / and 'Greenfire               |
;|                              / / /___\// / // /\/ /\  / /___\/   / / Productions'                  |
;|                             / / ___/\ / / // __  / / / ___/\    / / production.                    |
;|                            / / /\__\// / // / /\ \/ / /___\/   / / See the README                  |
;|                           / /_/ /   /_/ //_/ / /_/\/____/\    / / for more details.                |
;|                          /  \_\/    \_\/ \_\/  \_\/\____\/   /_/______________                     |
;|                         / _______   ____      ____     _____    __  __       /\                    |
;|                        / /__  __/\ / __ \    / __ \   / __  /\ / /\/ /\     / /                    |
;|                       /  \_/ /\_\// /\/ /\  / /\/ /\ / /\/_/ // /_/_/ /    / /                     |
;|                      /    / / /  / __  / / / __  / // / _\_\// __ \_\/    / /                      |
;|                     /    / / /  / / /\ \/ / / / / // /_/ /\ / / /\ \     / /                       |
;|                    /    /_/ /  /_/ / /_/\/_/ /_/ //_____/ //_/ / /_/\   / /                        |
;|                   /     \_\/   \_\/  \_\/\_\/\_\/ \_____\/ \_\/  \_\/  / /                         |
;|                  /                              _________________     / /                          |
;|                 /____________________________  /                /\   / /                           |
;|                 \___________________________/ /___   ___   ____/ /  / /                            |
;|                                            /  \__/  /\_/  /\___\/  / /                             |
;|                  Benjamin Ryves 2004      /     /  / //  / /      / /                              |
;|                 Based on the BBC Micro   /     /  / //  / /      / /                               |
;|                version.                 /  ___/  /_//  /_/__    / /                                |
;|               (Electric Dreams, a      /  /                /\  / /                                 |
;|              Software Studios         /  /________________/ / / /                                  |
;|             Production).             /   \________________\/ / /                                   |
;|            w: www.benryves.com      /_______________________/ /                                    |
;|           e: benryves@benryves.com  \_______________________\/                                     |
;|                                                                                                    |
;+====================================================================================================+
;| Written and Designed by Benjamin Ryves. Designed to be compiled under z80 Workshop. Other credits: |
;| => KEYVAL.INC values thanks to John Wyrwas.                                                        |
;| => SPRITE.INC sprite drawing routines thanks to James Vernon of the TCPA.                          |
;| => LEVELMAN.INC RLE decompression code and Windows compressor by Joe Pemberton.                    |
;| => GENERAL.INC RLE decompression code by David Phillips.                                           |
;| => PATHS.INC Thanks to Joe P for the idea on how to make the paths ~50% smaller, saving 506 bytes! | 
;+====================================================================================================+
;| Many thanks are extended to the guys at MaxCoderz for their continued support, ideas, approval and |
;| occasional insanity. I would thank Greenfire too, but most of you guys hang out at MaxCoderz anyway|
;| 'cos the site wasn't up. Anyway, this is a Greenfire game, not a MaxCoderz game, so I guess I had  |
;| better stay loyal to you all. Here's hoping to continued game production from all the guys!        |
;+====================================================================================================+
;| Notes on 2nd Release: The source has been updated a little to allow it to work on the regular 83   |
;| model calculator. The only blatent difference between between the 83+ and 83 versions is that high |
;| score initials entering uses the small graph font, as the flags to get it to work in BIG letters   |
;| didn't apply to the 83. It looks a bit odd, but beyond that it's the same. A few little differences|
;| under the bonnet, but beyond that it's near-as-damnit the same.                                    |
;| Oh, and there was a bug fix for the black TI-83 Plus and 83 -> Pressing [*] no longer makes you go |
;| up the screen.                                                                                     |
;+====================================================================================================+


; ==================================================================================================
; Headers - Sorts out the game header (really?)
; ==================================================================================================

#define equ .equ
#define EQU .equ
#define END .end

#include "config.inc"		;game settings.
#include "keyval.inc"		;key values for direct key input.

; ==================================================================================================
; TI-83 Ion
; ==================================================================================================

#ifdef TI83I
.org 9327h
	ret
	jr nc,Start
#include "ti83asm.inc"
#include "tokens.inc"
#include "ion83.inc"

;TI-83 Plus compatibility issues:
#define	bcall(label)	call label
_zeroop1		.equ		_zerooop1     
AppBackupScreen	=858Fh 	;Smaller than TI-83Plus version : be careful!
_createprog .equ 448Ah
#endif

; ==================================================================================================
; TI-83 Plus Ion
; ==================================================================================================

#ifdef TI83P
#define	bcall(label)	RST 28h \ .dw label
.org 9D93h
.db $BB,$6D
	ret
	jr nc,Start
#include "ti83plus.inc"
#include "ion8X.inc"
#endif

; ==================================================================================================
; TI-83 Plus MirageOS - Cool Icon.
; ==================================================================================================

#ifdef TI83M
#define	bcall(label)	RST 28h \ .dw label
.org 9D93h
.db $BB,$6D
	ret
.db 1
.db %11111111, %11111110
.db %11111111, %11111110
.db %11111111, %11111110
.db %11110111, %01100110
.db %11101110, %11010110
.db %11011100, %11110110
.db %11010110, %11101110
.db %11001110, %11011110
.db %11011110, %11011110
.db %11011110, %11010110
.db %11011110, %11001110
.db %11011110, %11011110
.db %11111111, %11111110
.db %11111111, %11111110
.db %11111111, %11111110
#include "ti83plus.inc"
#include "mirage.inc"
#endif


Description:
.db "Fire Track 2"

#ifdef BETA
.db " - Beta"
#endif

.db 0	;End the string.

; ==================================================================================================
; End of headers:
; ==================================================================================================


Start:

	im 1
	ld a,(Contrast)
	add a,18h
	ld (True_Contrast),a

#ifdef BETA
	ld hl,Beta
	ld de,PlotsScreen+264
	ld bc,12*20
	call RLE
	call ionFastCopy
	call Wait_2nd
	bcall(_grbufclr)
#endif



; ==================================================================================================
; Create the page file in RAM
; ==================================================================================================

	call Create_Page_File
	call EmptyPageFile

	;Set up a few values:

	ld hl,(PageFileLoc)
	ld de,767
	add hl,de
	ld (Back_copy_1+1),hl

	ld hl,(PageFileLoc)
	ld de,767+(12*8)
	add hl,de
	ld (Back_copy_2+1),hl

	ld hl,(SetMaskPos_3+1)
	ld de,767
	add hl,de
	ld (SetMaskPos_3+1),hl

	ld hl,(SetMaskPos_4+1)
	ld de,767+(12*8)
	add hl,de
	ld (SetMaskPos_4+1),hl

	;Align star values:

	ld hl,(SetStarPos+1)
	ld de,767-12
	add hl,de
	ld (SetStarPos_2+1),hl

	ld hl,(SetStarPos+1)
	ld de,767
	add hl,de
	ld (SetStarPos_3+1),hl

	ld hl,(SetStarPos+1)
	ld de,768-12
	add hl,de
	ld (SetStarPos_4+1),hl

; ==================================================================================================
; Roll the intro flames:
; ==================================================================================================

	;"Greenfire presents"

	ld hl,Greenfire
	ld de,PlotsScreen+(12*27)
	ld bc,12*9
	ldir

	call Screen_Invert

	call ionFastCopy
	ld hl,30000
G_F_Loop:
	push hl
	bcall(_getcsc)
	or a
	jr nz,Go_To_Game
	pop hl
	dec hl
	ld a,l
	or h
	jr nz,G_F_Loop
	push hl
Go_To_Game:
	pop hl
	bcall(_getcsc)
	
MainMenu_Start:


;Clear Dither buffer:
	xor a
	ld hl,DitherBuffer
	ld bc,24*16
	bcall(_memset)
	
Cancel_Selection:

	call Intro

	cp skClear
	jp z,Quit
	
	
; ==================================================================================================
; Game type selection menu:
; ==================================================================================================

	;Save flame:

	ld hl,(PageFileLoc)
	ld de,144
	add hl,de
	ex de,hl
	ld hl,DitherBuffer
	ld bc,24*16
	ldir

	;Decompress selection rectangle sprite:

	ld hl,Selection_Rect
	ld de,(PageFileLoc)
	ld bc,144
	call RLE

	;Create greyscale buffers:

	call Init_Grey


Redraw_SelectionMenu:
	bcall(_getcsc)
PollKeys:

	ld hl,Game_Selection
	ld de,PlotsScreen+228
	ld bc,300
	call RLE

	;Draw selection rectangle:

	ld hl,Game_Pos
	ld a,(Game_Type)
	ld e,a
	ld d,0
	add hl,de
	ld a,(hl)
	ld l,a
	xor a
	ld c,12
	ld b,12
	ld ix,(PageFileLoc)
	call ionLargeSprite

	call SwapBuffers
	call ionFastCopy

	bcall(_getcsc)
	or a
	jr z,PollKeys

	cp skClear
	jr nz,No_Cancel_Selection

	ld hl,(PageFileLoc)
	ld de,144
	add hl,de
	ld de,DitherBuffer
	ld bc,24*16
	ldir

	jp Cancel_Selection

No_Cancel_Selection:

	cp sk2nd
	jr z,Selected_Game

	ld a,(Game_Type)
	xor 1
	ld (Game_Type),a

	jr Redraw_SelectionMenu

Selected_Game:

	;Start from level 1, clear score:

	xor a
	ld (Level_Num),a
	;Clear the score
	ld hl,Score
	ld bc,6
	xor a
	bcall(_memset)

	;Set lives to 4:

	ld a,3
	ld (Lives),a

; ==================================================================================================
; Copy the high score table for this particular mode of play to the high score table buffer:
; ==================================================================================================

	ld hl,Classic_Scores
	ld bc,27
	ld de,High_Score_1
	ld a,(Game_Type)
	or a
	jr z,Is_Classic_Scores

	ld hl,Extended_Scores
Is_Classic_Scores:
	ldir

	;Display high score table:

	call DisplayScores
	call Wait_2nd

Start_New_Level:
Start_Level:			;Jump to here before a level is started.

	call EmptyPageFile

; ==================================================================================================
; Copy the "base" to the level buffer.
; ==================================================================================================

	ld de,(LevelLoc)
	inc de
	ld hl,Start_Base+12
	ld bc,12*10
	ldir

; ==================================================================================================
; Now, load the level. As such, DE is the pointer to the start of the level area.
; ==================================================================================================

	ld a,(Game_Type)
	or a
	jp z,Load_Premade_Level

; ==================================================================================================
; The super-mega-random-level-create-o-tron®
; ==================================================================================================

	;OK, so what do we need to do? Create a random level!

	dec de

	;How many level large chunks should we have?
	ld a,4
	ld (PlotsScreen),a

Next_main_Chunk:


	;Every chunk should start with at least 1 line of space:

	call AddRandomSpace

	;Now, add a "space" chunk:
		
	ld b,(EO_Sp-Space_Chunks)/2
	call ionRandom
	ld bc,Space_Chunks
	call Copy_Chunk

	call AddRandomSpace


	;So we're to make a chunk. Right. Start with an intro piece:

	ld b,(EO_S-Start_Chunks)/2
	call ionRandom
	ld bc,Start_Chunks

	call Copy_Chunk

	;Now copy in a few middle pieces:

	ld b,5
	call ionRandom
	inc a
	ld (PlotsScreen+1),a		;How many "middle chunks" should I use?
Copy_Next_Mid:
	ld b,(EO_M-Mid_Chunks)/2
	call ionRandom
	
	ld bc,Mid_Chunks
	call Copy_Chunk

	ld a,(PlotsScreen+1)
	dec a
	ld (PlotsScreen+1),a
	or a
	jr nz,Copy_Next_Mid


	;All the middle chunks are done -- add an end chunk:

	ld b,(EO_E-End_Chunks)/2
	call ionRandom
	ld bc,End_Chunks
	call Copy_Chunk

	
	ld a,(PlotsSCreen)
	dec a
	ld (PlotsScreen),a
	or a
	jr nz,Next_main_Chunk

	;All done, so add the "next zone" platform (but not after we have put in a gap!)

	call AddRandomSpace


	xor a
	ld (Use_Face),a

	ld (de),a

	inc de

	ld hl,Start_Base
	ld bc,11*12
	ldir

	ld bc,12*8
	push de
	pop hl
	xor a
	bcall(_memset)
	;Now, fix the level end marker:


	ld hl,12
	add hl,de
	ld (Level_End),hl
	
	jr Made_Level

; ==================================================================================================
; Copies chunk #a from list @ (bc) onto level.
; ==================================================================================================

Copy_Chunk:
	ld l,a
	ld h,0
	add hl,hl
	add hl,bc

	push hl
	pop ix
	
	ld h,(ix+1)
	ld l,(ix+0)
	
	;HL = ptr to level chunk:

	push hl
	pop ix
	ld b,(ix+1)
	ld c,(ix+0)

	;BC = size

	inc hl
	inc hl

	ldir		;Copy chunk.
	ret

; ==================================================================================================
; Adds a random few lines of space to the level.
; ==================================================================================================

AddRandomSpace:

	ld b,3
	call ionRandom
	inc a
	ld l,a
	ld h,0
	add hl,hl
	add hl,hl	;hl=hl*4
	push hl
	pop bc
	add hl,hl
	add hl,bc
	push hl
	pop bc
	push de
	pop hl
	xor a
	bcall(_memset)
	ret

; ==================================================================================================
; Decompress the level into the page file:
; ==================================================================================================
Load_Premade_Level:
	push de
	ld a,(Level_Num)
	add a,a
	ld e,a
	ld d,0
	ld hl,Level_Table
	add hl,de
	push hl
	pop ix

	ld h,(ix+1)
	ld l,(ix+0)

	pop de
	call Load_Level

; ==================================================================================================
; Set the "Level Pointer" value to the start of the level in RAM (within the page file).
; ==================================================================================================
Made_Level:
	ld hl,(LevelLoc)
	ld (Level_Pointer),hl

; ==================================================================================================
; Set up some starting values.
; Scroll_Amt: How much the screen is scrolled by (in pixels) when copied from the large buffer.
;             It works like this: Scroll_Amt goes 8,7,6,5,4,3,2,1 add new row sprites, start from 8.
; BG_Scroll_Delay: How many game loops to cycle through until the background is shifted 1 pixel.
; ==================================================================================================

	ld a,8
	ld (Scroll_Amt),a
	ld (Explosion_Delay),a

	ld a,BG_Scroll_Delay
	ld (Scroll_Delay),a

; ==================================================================================================
; Now copy in a few rows of the level (ie the starting platform) onto the large buffer.
; ==================================================================================================


	ld a,9
Copy_Base_Start:
	push af
	call Shift_8	
	call Draw_Row
	pop af
	dec a
	or a
	jr nz,Copy_Base_Start


; ==================================================================================================
; Random starfield generator
; ==================================================================================================

	ld hl,PlotsScreen
	ld a,$FF
	ld bc,768	
	bcall(_memset)

	ld b,100
	call ionRandom
	add a,20

Add_Next_Star:
	push af

	ld b,63
	call ionRandom
	push af

	ld b,95
	call ionRandom
	pop bc
	ld e,b

	call ionGetPixel

	cpl
	ld b,a
	ld a,(hl)
	and b
	ld (hl),a
	
	pop af

	dec a
	or a
	jr nz,Add_Next_Star

	ld hl,PlotsScreen
	ld de,(SetStarPos+1)
	ld bc,768
	ldir

; ==================================================================================================
; If killed, return to this point.
; ==================================================================================================


Return_From_Dead:

	; Set up the delay between enemy waves (shorter for harder levels)

	ld d,100

	ld a,(Level_Num)
Get_Enemy_Delay:
	or a
	jr z,Set_Enemy_Delay
	dec a	
	sra d
	jr Get_Enemy_Delay

Set_Enemy_Delay:

	ld a,d
	ld (Delay_Enemies),a

	ld a,128
	ld (Powerup_Y),a

	ld b,96-8
	call ionRandom
	ld (Mine_X),a
	ld a,-8
	ld (Mine_Y),a

	ld a,ExtraShipDuration
	ld (Extra_Ship_Delay),a

	xor a
	ld (Death_Timer),a
	ld (EMP_Pos),a
	ld (MOde_Down),a
	ld (Num_Powerups),a
	ld (Laser_Running),a
	ld (Slow_Running),a
	ld (Blown_Up_Ground),a		;Must be done, so as to make sure that the terrain is not corrupted.
	ld (Kamikaze_Active),a
	ld (Speed_Active),a

	ld a,(Scroll_Amt)
	call Copy_Bg

	call ionFastCopy

	;Clear explosion buffer:

	ld hl,Explosion_Buffer
	ld bc,16*3
	xor a
	bcall(_memset)

	;Restart enemy attack:

	ld b,(End_Attack_List-Attack_List)/3
	call ionRandom
	inc a
	call Start_Attack

	;Reset ship position

	ld bc,(44*256)+54
	ld (Ship_Y),bc

	;Rehash the background:


	;Clear all enemies:

	ld hl,Enemies
	ld bc,(Num_Enemies)*4
	ld a,128
	bcall(_memset)

	;Reset bullet points:

	ld hl,Bullet_Reset
	ld de,Bullet_Pos
	ld bc,4*3
	ldir
	

	;Put the "extra ships" into position.

	ld hl,Extra_Orig
	ld de,Extra_Ships
	ld bc,3
	ldir


	ld hl,Extra_Active
	ld bc,3
	xor a
	bcall(_memset)
	ld a,(Lives)
	cp -1
	jp z,Game_Over

	ld ix,Extra_Active

Enable_next_Ship:	


	or a
	jr z,Done_Active_Ships

	ld (ix+0),1
	inc ix
	dec a
	jr Enable_next_Ship

Done_Active_Ships:

; ==================================================================================================
; Main Game Loop:
; ==================================================================================================

Game_Loop:

; ==================================================================================================
; Handle the scrolling background. (includes scrolling the face at the end of each level).
; ==================================================================================================

	ld a,(Scroll_Delay)
	dec a
	ld (Scroll_Delay),a
	or a
	jr nz,NoScrollYet

	;Scrolling: move all the explosions down:

	ld hl,Explosion_Buffer+1
	ld a,Max_Explosions
Shift_Explosions_Loop:	
	inc (hl)
	inc hl
	inc hl
	inc hl
	dec a
	or a
	jr nz,Shift_Explosions_Loop

	ld a,(Scroll_Amt)
	dec a
	or a
	jr nz,Fix_Scroll_Amt
	call Shift_8
	call Draw_Row

	;Now, check to see if we should loop the end face:
	ld hl,(Level_Pointer)
	ld de,(Level_End)

	bcall(_cphlde)
	jr c,Not_End_Of_Level		

	ld a,(use_Face)
	or a
	jp z,Completed_Level

	ld hl,(Level_LpPoint)
	ld (Level_Pointer),hl
	xor a
	ld (Blown_Up_Ground),a


	

Not_End_Of_Level:
	ld a,8
Fix_Scroll_Amt:
	ld (Scroll_Amt),a
	ld a,BG_Scroll_Delay
	ld (Scroll_Delay),a	
NoScrollYet:


; ==================================================================================================
; Copy the background to the graph buffer:
; ==================================================================================================

#ifndef Hide_Back
	ld a,(Scroll_Amt)
	call Copy_Bg
#else
	bcall(_grbufclr)
#endif

; ==================================================================================================
; Draw in the explosions:
; ==================================================================================================

	;(Lower value of A to skip to next animation frame)

	ld a,(Explosion_Delay)
	dec a
	or a
	jr nz,No_Change_Frame
	
	;Time to make a change:

	ld de,3

	ld hl,Explosion_Buffer+2

Advance_Next_Sprite:

	ld a,(hl)
	or a
	jr z,Not_Yet_Active_Explosion
	cp 128
	jr z,Done_All_Explosions_Sprites
	
	sub 16
	ld (hl),a
Not_Yet_Active_Explosion:
	add hl,de
	jr Advance_Next_Sprite


Done_All_Explosions_Sprites:


	

	ld a,Explosion_Frame_Rate
	
No_Change_Frame:
	ld (Explosion_Delay),a


	ld ix,Explosion_Buffer

Draw_Explosions_Loop:

	ld a,(ix+2)	;Enabled?
	or a
	jr z,Next_One_In_Buffer

	cp 128
	jr z,Done_All_Explosions

	;Enabled, so find correct sprite:

	ld l,a
	ld h,0
	ld de,Explosions-16
	
	add hl,de	;HL now equals correct sprite.


	ld b,(ix+0)	;\ Get position of sprite.
	ld c,(ix+1)	;/


	push ix

	call putClippedMaskedSprite

	pop ix




Next_One_In_Buffer:

	inc ix
	inc ix
	inc ix

	jr Draw_Explosions_Loop
Done_All_Explosions:

; ==================================================================================================
; Draw the powerup icon:
; ==================================================================================================

	ld a,(Game_Type)
	or a
	jr z,No_Powerup

	ld a,(Powerup_Y)
	cp 128
	jr z,No_Powerup

	ld bc,(Powerup_Y)
	ld hl,PowerUp_Sprite
	call putClippedMaskedSprite

No_Powerup:

; ==================================================================================================
; Draw the ship sprite:
; ==================================================================================================

	ld a,(Death_Timer)
	or a
	jr nz,Dont_Draw_Main_Ship

	ld a,(Shield_Time)
	or a
	jr z,Normal_Ship

	ld bc,(Ship_Y)
	ld hl,MainShip_Shield
	call putClippedMaskedSprite

	jr Dont_Draw_Main_Ship
Normal_Ship:
	ld bc,(Ship_Y)
	ld hl,MainShip
	call putClippedMaskedSprite
Dont_Draw_Main_Ship:

; ==================================================================================================
; Draw the "helper ship" sprites: (if active)
; ==================================================================================================

	ld ix,Extra_Active
Check_Next_Helper:
	ld a,(ix+0)
	or a
	jr z,Helper_Is_Inactive
	cp 128
	jr z,Finished_Helpers

	ld b,(ix+4)
	ld c,54

	ld a,(Extra_Ship_Delay)
	or a
	jr nz,Dont_Shift_ES

	dec (ix+4)
	ld a,(ix+4)
	cp -8
	jr nz,Dont_Disable_Helper_Yet

	ld (ix+0),0
	jr Dont_Disable_Helper_Yet

Dont_Shift_ES:

	dec a
	ld (Extra_Ship_Delay),a

Dont_Disable_Helper_Yet:
	push ix
	
	ld hl,MainShip
	call putClippedMaskedSprite

	pop ix

Helper_Is_Inactive:
	inc ix
	jr Check_Next_Helper
	

Finished_Helpers:

; ==================================================================================================
; Draw the enemies:
; ==================================================================================================



	ld ix,Enemies

Draw_Next_Enemy:
	
	ld a,(ix+2)
	cp 128
	jr z,Drawn_All_Enemies

	ld b,(ix+0)
	ld c,(ix+1)

	ld a,(ix+3)
	or a
	jr z,SkipEnemy

	ld a,(ix+2)
	bit 0,a						;Draw enemy?
	jr z,SkipEnemy

	push ix
	ld hl,Enemy_Cache
	call putClippedMaskedSprite
	pop ix

SkipEnemy:

	call Add_ix_4
	jr Draw_Next_Enemy

Drawn_All_Enemies:

; ==================================================================================================
; Move the enemies:
; ==================================================================================================


	ld a,(Slow_Running)
	or a
	jr z,Move_Enemies_As_Normal

	dec a
	ld (Slow_Running),a
	jp No_Move_Enemies

Move_Enemies_As_Normal:

; ==================================================================================================
; Check which attack type:
; ==================================================================================================


	ld a,(Attack_Type)
	cp 1
	jr z,Path_Based_Attack_Move
	cp 2
	jr z,Scroll_Enemies_Move
	cp 3
	jr z,Scroll_Enemies_Move

; ==================================================================================================
; Move enemies along a path
; ==================================================================================================
Path_Based_Attack_Move:
	ld a,Num_Enemies
	ld bc,Enemies+3
	ld ix,Enemies
	ld de,(Path_Pointer)
	
Move_Next_Enemy:


	ld a,(ix+2)
	cp 128
	jp z,Enemies_Moved_Done

	or a
	jr z,Skip_This_One_Its_Dead

	

	ld a,(bc)
	ld l,a
	ld h,0
	add hl,hl
	add hl,de
	
	ld a,(hl)
	ld (ix+1),a
	inc hl
	ld a,(hl)
	ld (ix+0),a

	inc (ix+3)

	ld a,(ix+3)
	ld h,a
	ld a,(Path_Progress)
	cp h
	jr c,Not_Yet_Active	;Too big!
	or a
	jr z,Not_Yet_Active

	ld a,1
	ld (ix+2),a
	jr Activated

Not_Yet_Active:
	;Now, is it too big because it is ABOVE or BELOW the screen?
	ld a,(ix+2)
	cp 1			;Active...
	jr z,Off_Bottom

	jr Skip_This_One_Its_Dead

Off_Bottom:
	xor a
	ld (ix+2),a


Activated:
Skip_This_One_Its_Dead:		;Should be "It's" dead, but TASM doesn't like "'".

	inc bc
	inc bc
	inc bc
	inc bc

	call Add_ix_4
	
	jr Move_Next_Enemy

Path_Not_Active:

Skip_Enemy_Moving:
	jp Enemies_Moved_Done

; ==================================================================================================
; Move enemies down one pixel (nice and easy then)
; ==================================================================================================

Scroll_Enemies_Move:
	
	ld ix,Enemies

Scroll_Next_Enemy:

	ld a,(ix+2)
	cp 128
	jr z,Done_All_Scrolls

	ld a,(ix+2)
	or a
	jr z,This_Enemy_has_Died

	cp 1
	jr z,Active_Enemy_Scrolling

	;Enemy is a "#2": it is off the top of the screen (not yet enabled)... or is it?

	ld a,(ix+1)		;Y position
	cp -8
	jr nz,Active_Enemy_Scrolling	;Ship is not yet on screen, but shift it anyway
	
	ld (ix+2),1		;Enable enemy.

Active_Enemy_Scrolling:
	inc (ix+1)
	ld a,(ix+1)	;"Y" position.
	cp 64
	jr nz,Not_Off_Bottom_Scroll


	ld (ix+2),0


Not_Off_Bottom_Scroll:

	
This_Enemy_has_Died:
	call Add_ix_4


	jr Scroll_Next_Enemy
		
Done_All_Scrolls:

; ==================================================================================================
; Jump here when all the enemies have been moved:
; ==================================================================================================

Enemies_Moved_Done:

	ld a,(Attack_Type)
	cp 3
	jr nz,Not_Intelligent_Attack
	ld ix,Enemies
	ld bc,(Ship_Y)

Intelligent_Attack:
	ld a,(ix+2)
	cp 128
	jr z,Not_Intelligent_Attack
	bit 0,a
	jr z,I_Not_Active
	
	ld a,(ix+1)
	cp 20
	jr c,I_Not_Active

	ld a,(ix+0)
	cp b

	jr z,I_Not_Active

	jr c,I_Shift_Right


I_Shift_Left:	dec (ix+0) \ jr I_Not_Active
I_Shift_Right:	inc (ix+0)

I_Not_Active:

	call Add_ix_4
	jr Intelligent_Attack
	
Not_Intelligent_Attack:

; ==================================================================================================
; Check to see if the enemies have done all they need to, and if so start a new attack pattern
; ==================================================================================================


	ld ix,Enemies

Scan_Active_Enemies:
	ld a,(ix+2)
	cp 128
	jr z,All_Enemies_Dead
	or a
	jr nz,Some_Enemies_Active
	call Add_ix_4
	jr Scan_Active_Enemies

All_Enemies_Dead:


	ld a,(Death_Timer)
	or a
	jr nz,Dead_No_Enemy



	ld a,(Delay_Between_Enemies)
	dec a
	ld (Delay_Between_Enemies),a
	or a
	jr nz,Some_Enemies_Active



	ld b,(End_Attack_List-Attack_List)/3
	call ionRandom
	inc a
	call Start_Attack
Dead_No_Enemy:

Some_Enemies_Active:

Finished_All_Attacks:


No_Move_Enemies:

; ==================================================================================================
; Draw the bullets:
; ==================================================================================================


	ld ix,Bullet_Pos

	ld a,NUM_BULLETS
Draw_Next_Bullet:
	push af
	push ix


	ld a,(ix+2)
	or a
	jp z,Bullet_Inactive
	ld b,(ix+0)
	ld c,(ix+1)



	ld a,(Ship_Y)			;Where is it in relation to the ship?
	cp 96
	jp nc,Bullet_Inactive

	ld d,a

	ld a,c
	add a,6

	cp d 
	jr c,In_Front_Of_Ship

	ld a,(Ship_X)
	ld (ix+0),a

	jp Bullet_Inactive

In_Front_Of_Ship:



	ld (Reg_16_2),ix

	;Now; check, have we hit anything?

; ==================================================================================================
; Check to see if a bullet has hit something on the ground
; ==================================================================================================


	push bc	;Preserve (x,y)



	call FindLocation
	push hl
	ld a,(hl)
	ld (Reg_16_1),a

	;Look it up: can we break it?

	ld bc,End_Of_Breakable_Tiles-Breakable_Tiles
	ld hl,Breakable_Tiles
	cpir
	jp nz,Not_Hit_Breakable_Tile

	;We have hit something...

	;Calculate # of points:

	ld de,(End_Of_Breakable_Tiles-Breakable_Tiles)-1
	add hl,de
	ld a,(hl)

	call Add_To_Score

	ld (ix+2),0


	ld b,35

	ld a,(Reg_16_1)

	;Spaghetti code for 4-block tiles (turret and doughnut)

 	cp 20 \ call z,Set_b_40
 	cp 21 \ call z,Set_b_41
 	cp 22 \ call z,Set_b_42
 	cp 23 \ call z,Set_b_43

 	cp 31 \ call z,Set_b_40
 	cp 32 \ call z,Set_b_41
 	cp 33 \ call z,Set_b_42
 	cp 34 \ call z,Set_b_43

	
	;Now the bullet is disabled, the fun can begin: copy in the "exploded" tile:

	pop ix 		;[ix= location of exploded tile in RAM]
	ld (ix+0),b	;Load in the broken tile image. (to stop it from being re-hit, and for scrolling face @ the end).
	ld (BlownUpTileLoc),ix
	
	;Now, I have to draw in the sprite over where it hit:

	ld a,1
	ld (Blown_Up_Ground),a

	pop de
	call Add_Explosion
	push de
	pop bc 

	jr Done_Breakable_Tiles

	

Not_Hit_Breakable_Tile:
	pop hl
	pop bc

Done_Breakable_Tiles:

; ==================================================================================================
; Check the bullet against the enemy ship:
; ==================================================================================================

	push bc

	push bc
	pop hl
	ld bc,$8080
	add hl,bc
	push hl
	pop bc

	;Now we check to see if we've shot an enemy ship.


	ld ix,Enemies
	
Check_Next_Enemy:
	ld a,(ix+2) 	
	cp 128
	jr z,Checked_All_Enemies
	cp 1
	jr nz,This_Enemy_Inactive


	;Now I check to see if the enemy is in the range of my bullet:

	ld a,(ix+0)	;Check X first.
	add a,$80-2d
	cp b
	jr nc,Out_Of_Bounds

	add a,8
	cp b
	jr c,Out_Of_Bounds


	ld a,(ix+1)	;Now check y
	add a,$80-12d
	cp c
	jr nc,Out_Of_Bounds

	add a,16
	cp c
	jr c,Out_Of_Bounds

	;We have hit a ship!


	ld a,(E_PointsAvailable)
	call Add_To_Score

	ld hl,(Reg_16_2)
	inc hl
	inc hl
	xor a
	ld (hl),a	;Disable the bullet.

	ld a,(Blocker)
	or a
	jr nz,Is_Blocker		;Don't kill the ship, but do disable the bullet!

	xor a
	ld (ix+2),a	;Disable the ship.

	ld d,(ix+0)
	ld e,(ix+1)
	push bc
	call Add_Explosion
	pop bc
Is_Blocker:


Out_Of_Bounds:
	

This_Enemy_Inactive:

	call Add_ix_4
	jr Check_Next_Enemy

Checked_All_Enemies:



	pop bc

	push bc
	ld hl,Bullet
	call putClippedMaskedSprite
	pop bc

; ==================================================================================================
; Move the bullet
; ==================================================================================================

Bullet_Inactive:
	
	pop ix

	dec (ix+1)
	dec (ix+1)

	ld a,(Fired)
	or a
	jr z,No_Fire

	ld a,(ix+1)
	add a,128
	ld b,a
	
	ld a,(Ship_Y)
	add a,128-10

	cp b
	jr nc,No_Fire
	add a,16
	cp b
	jr c,No_Fire
	
	ld a,(Ship_X)
	ld (ix+0),a

	ld (ix+2),1
	xor a
	ld (Fired),a

No_Fire:


	ld a,(ix+1)
	cp -8
	jr nz,No_Reset_Pos


	ld (ix+2),0

	ld a,64
	ld (ix+1),a

	ld a,(Death_Timer)
	or a
	jr nz,No_Reset_Pos

	ld a,(Game_Type)
	xor 1
	ld (ix+2),a


No_Reset_Pos:
	inc ix
	inc ix
	inc ix
	pop af
	dec a
	jp nz,Draw_Next_Bullet


; ==================================================================================================
; Move the powerup pickup -- if able.
; ==================================================================================================

	ld a,(Powerup_Y)
	cp 128
	jr z,P_Not_Active


	ld a,(PowerUpDelay)
	xor 1
	ld (PowerUpDelay),a
	or a
	jr z,Not_Shift_PUp

	ld a,(Powerup_Y)
	inc a
	ld (Powerup_Y),a

Not_Shift_PUp:
	cp 64
	jr nz,P_Not_Ended
	ld a,128
	ld (Powerup_Y),a

P_Not_Ended:
	ld bc,(Ship_Y)
	ld a,b
	add a,128
	ld b,a

	ld a,(Powerup_X)
	add a,120
	cp b
	jr nc,P_Not_Active
	add a,16
	cp b
	jr c,P_Not_Active
		
	ld a,(Powerup_Y)
	sub 8
	cp c
	jr nc,P_Not_Active
	add a,16
	cp c
	jr c,P_Not_Active

	;Whee, we have picked up a powerup.
	ld a,128
	ld (Powerup_Y),a
	ld b,(EO_Powerup_Table-Powerup_Table)/3
	call ionRandom
	call Start_Powerup
	
P_Not_Active:

; ==================================================================================================
; Handle the mine:
; ==================================================================================================

	ld a,(Death_Timer)
	or a
	jr nz,Mine_Not_Active


	ld a,(Level_Num)
	or a
	jr z,Mine_Not_Active

	ld bc,(Mine_Y)
	ld hl,Mine
	call putClippedMaskedSprite

	ld a,(Mine_Loop)
	or a
	jr nz,Mine_Not_Moving


	;Shift the mine.

	ld ix,Mine_Y

	ld hl,(Mine_Y)
	ld de,$8080		;Why the $8080? Answers on a postcard to: ....
	add hl,de

	push hl
	pop bc

	ld hl,(Ship_Y)
	ld de,$8080		;(Only kidding), it's to allow for negative numbers.
	add hl,de

	ld a,c
	cp l

	call c,Shift_Mine_D
	call nc,Shift_Mine_U

	ld a,b
	cp h

	call c,Shift_Mine_R
	call nc,Shift_Mine_L

	ld a,Mine_Speed
	jr Mine_Moved
Mine_Not_Moving:
	dec a
Mine_Moved:
	ld (Mine_Loop),a


	;Now the mine has been handled... have we hit the damn thing?

#ifndef Indestructable

	ld a,(Shield_Time)
	or a
	jr nz,Not_Hit_Mine

	ld bc,(Mine_Y)
	ld hl,(Ship_Y)

	ld a,b
	cp h
	jr nc,Not_Hit_Mine
	add a,8
	cp h
	jr c,Not_Hit_Mine


	ld a,c
	cp l
	jr nc,Not_Hit_Mine
	add a,8
	cp l
	jr c,Not_Hit_Mine


	;BOOM.

	ld de,(Mine_Y)
	call Add_Explosion
	ld a,ZombieTime
	ld (Death_Timer),a

#ifndef Infinite_Lives
	ld a,(Lives)
	sub 1
	ld (Lives),a
#endif

#endif

Not_Hit_Mine:
Mine_Not_Active:



; ==================================================================================================
; Handle the powerups:
; ==================================================================================================

;Check for EMP:
	ld a,(EMP_Pos)
	or a
	jr z,Not_EMP

	;COOL! It's the EMP!

	dec a
	ld (EMP_Pos),a

	ld l,a
	ld h,0
	add hl,hl
	add hl,hl
	push hl
	pop de
	add hl,hl
	add hl,de
	ld de,PlotsScreen
	add hl,de
	ld bc,24
	xor a
	bcall(_memset)

	;Now check enemies:

	ld a,(Ship_Y)
	ld b,a
	ld a,(EMP_Pos)
	sub 4
	ld c,a

	ld ix,Enemies

EMP_Destroy_Loop:	
	ld a,(ix+2)
	cp 128
	jp z,Done_PowerUps

	cp 1
	jr nz,EMP_ENA

	ld a,(ix+1)
	cp b
	jr nc,EMP_ENA
	cp c
	jr c,EMP_ENA

	;BOOM.
	ld (ix+2),0

	ld a,(E_PointsAvailable)
	call Add_To_Score
	
	push bc
	push ix

	ld d,(ix+0)
	ld e,(ix+1)
	call Add_Explosion

	pop ix
	pop bc



EMP_ENA:

	call Add_ix_4
	jr EMP_Destroy_Loop
	



Not_EMP:


;See if the laser is running:

	ld a,(Laser_Running)
	or a
	jp z,Not_Laser

	dec a
	ld (Laser_Running),a

	;This is the tricky part: drawing in the laser!


	ld a,(Ship_Y)
	ld l,a
	ld a,(Ship_X)
	add a,3


	ld (Reg_16_1),a
Draw_Laser_Loop:
	push hl
	ld ix,Laser_Beam
	ld b,1
	call ionPutSprite

	
	pop hl

	
	dec l
	ld a,l
	or a
	jr z,Drawn_In_Laser
	ld a,(Reg_16_1)
	jr Draw_Laser_Loop

Drawn_In_Laser:
	
	


;OK, so now it has been drawn: let the fun commence!
	ld a,(Ship_X)
	add a,4
	ld b,a
	
	ld ix,Enemies

Laser_Destroy_Loop:
	ld a,(ix+2)
	cp 128
	jr z,Done_Laser_Enemies
	cp 1
	jr nz,Loop_Next_Enemy

	;So, the enemy is active. But is it in line for a beatin'?

	ld b,(ix+0)

	ld a,(Ship_X)
	sub 4
	cp b
	jr nc,Loop_Next_Enemy

	add a,8
	cp b
	jr c,Loop_Next_Enemy

	;Woo, nearly:

	ld b,(ix+1)
	ld a,(Ship_Y)
	cp b
	jr c,Loop_Next_Enemy
	

	;BOOM
	ld (ix+2),0
	

	ld a,(E_PointsAvailable)
	call Add_To_Score

	ld d,(ix+0)
	ld e,(ix+1)
	call Add_Explosion
	

Loop_Next_Enemy:
	inc ix
	inc ix
	inc ix
	inc ix
	jr Laser_Destroy_Loop


Done_Laser_Enemies:


Not_Laser:
	
	ld a,(Kamikaze_Active)
	cp 20
	jr nz,Not_Kamikaze_F
	ld de,(Ship_Y)
	call Add_Explosion

#ifndef Infinite_Lives
	ld a,(Lives)
	sub 1
	ld (Lives),a
#endif

	ld a,ZombieTime
	ld (Death_Timer),a

	;Add 100pts!
	
	ld b,10

Add_100_Next:
	push bc
	ld a,10
	call Add_To_Score
	pop bc
	dec b
	ld a,b
	or a
	jr nz,Add_100_Next


	;Now we have done that, let's kill all the enemies and tally up a score!

	ld ix,Enemies
Check_Next_Kamikaze:
	ld a,(ix+2)
	cp 128
	jr z,Kamikazed_All

	cp 1
	jr nz,Kamikaze_Next

	push ix
	ld d,(ix+0)
	ld e,(ix+1)
	call Add_Explosion

	ld a,(E_PointsAvailable)
	call Add_To_Score
	pop ix
		


Kamikaze_Next:
	ld (ix+2),0	;Disable enemy!
	call Add_ix_4
	jr Check_Next_Kamikaze

Kamikazed_All:

Not_Kamikaze_F:


Done_PowerUps:


;Manage the shield:

	ld a,(Shield_Time)
	or a
	jr z,Not_Active
	dec a
	ld (Shield_Time),a
Not_Active:

; ==================================================================================================
; Copy it all to the display:
; ==================================================================================================


	call Draw_Score


	ld a,(Game_Type)
	or a
	jr z,Is_Classic_No_P

	ld a,(Num_Powerups)
	or a
	jr z,Is_Classic_No_P

	ld ix,PowerupCache
	ld hl,PlotsScreen+10
	ld de,12
	ld b,7

Loop_PSpr:
	ld a,(ix+0)
	ld (hl),a
	inc ix
	add hl,de
	dec b
	ld a,b
	or a
	jr nz,Loop_PSpr
	
	ld hl,PlotsScreen+11
	ld de,12
	ld b,7

Loop_PT:
	ld a,(ix+0)
	ld (hl),a
	inc ix
	add hl,de
	dec b
	ld a,b
	or a
	jr nz,Loop_PT

	ld a,(Num_Powerups)
	ld b,a
	add a,a
	add a,a
	add a,b
	ld l,a
	ld h,0

	ld de,Numbers
	add hl,de
	push hl
	pop ix

	ld hl,PlotsScreen+23
	ld de,12
	ld b,5

Loop_PN:
	ld a,(ix+0)
	srl a
	srl a
	srl a
	srl a
	ld c,a
	ld a,(hl)
	xor c
	ld (hl),a
	inc ix
	add hl,de
	dec b
	ld a,b
	or a
	jr nz,Loop_PN
	

Is_Classic_No_P:

	ld a,(Kamikaze_Active)
	or a
	jr z,Not_Kamikaze

	dec a
	ld (Kamikaze_Active),a

	;Now, do we really have to kamikaze-invert?

	bit 0,a
	jr z,Not_Kamikaze
	
	;Invert the entire screen!

	call Screen_Invert


Not_Kamikaze:
	call ionFastCopy

; ==================================================================================================
; Blown_Up_Ground
; ==================================================================================================
	ld a,(Blown_Up_Ground)
	or a
	jr z,Not_Hit_Anything_Ground


	ld a,(Game_Type)
	or a
	jr nz,Not_Blown_Up_Eyes		;Can't blow up the eyes if in extended mode.

	;Blown up the 2 eyes?

	ld a,(Level_Num)
	bit 0,a
	jr nz,Not_Blown_Up_Eyes

	ld hl,(Eye_1)
	ld a,(hl)
	cp 25
	jr z,Not_Blown_Up_Eyes
	ld hl,(Eye_2)
	ld a,(hl)
	cp 25
	jp nz,Completed_Level

Not_Blown_Up_Eyes:

	ld hl,(Level_Pointer)
	dec hl
	ld de,(BlownUpTileLoc)
	ld a,(de)
	ld (Reg_16_1),a
	
	xor a
	or a	
	sbc hl,de


	;HL now equals how many bytes are to the hit tile from the top-left of the screen.

	;Convert it to a coordinate:

	ld a,0
	ld b,0

Check_Next_Coordinate:
	inc a 
	cp 12	;Right-most edge of screen
	jr nz,Not_Looped_X

	inc b
	xor a

Not_Looped_X:

	;Now check loop:

	ld c,a
	
	dec l

	ld a,l
	or a
	jr z,Found_Coordinates
		
	ld a,c

	jr Check_Next_Coordinate


Found_Coordinates:

	ld a,b			;Fix slight memory corruption bug (only affected level data, but still a problem! We musn't have corrupted RAM!)
	cp 8
	jp nc,Skipped_Sprite




	ld a,11
	sub c
	
	ld l,b

	push hl
	push af


	ld a,(Reg_16_1)
	ld l,a
	ld h,0
	add hl,hl
	add hl,hl
	add hl,hl

	ld de,Background_Tiles-8
	add hl,de

	push hl
	pop ix

	pop af
	pop hl
	

	call putSprite_LargeBuffer_Y


Skipped_Sprite:
	xor a
	ld (Blown_Up_Ground),a




Not_Hit_Anything_Ground:


; ==================================================================================================
; Check to see if we have crashed into an enemy ship:
; ==================================================================================================

#ifdef Indestructable
	jp Finished_Enemy_Crash
#endif

	ld a,(Kamikaze_Active)
	or a
	jr nz,Finished_Enemy_Crash	;Just in case we end up with losing 2 lives!

	ld a,(Death_Timer)
	or a
	jr nz,Finished_Enemy_Crash

	ld ix,Enemies
	ld hl,(Ship_Y)
	ld de,$8080
	add hl,de
	push hl
	pop bc

	ld a,c
	add a,8
	ld c,a

Crash_Checker:	
	ld a,(ix+2)
	cp 128
	jr z,Finished_Enemy_Crash
	bit 0,a
	jr z,Enemy_Not_Enabled

	ld a,(ix+3)
	or a
	jr z,Enemy_Not_Enabled


	ld a,(ix+1)
	cp 88
	jr nc,Not_Crashed

	ld a,(ix+0)
	add a,$80-6d
	cp b
	jr nc,Not_Crashed
	add a,12
	cp b
	jr c,Not_Crashed
	
	ld a,(ix+1)
	add a,$80
	cp c
	jr nc,Not_Crashed
	add a,12
	cp c
	jr c,Not_Crashed

	;Now we have crashed!

	ld (ix+2),0

	ld de,(Ship_Y)
 	call Add_Explosion

	ld a,(Shield_Time)
	or a
	jr nz,Not_Hit_Ship

#ifndef Infinite_Lives
	ld a,(Lives)
	sub 1
	ld (Lives),a
#endif




	ld a,ZombieTime
	ld (Death_Timer),a


Not_Hit_Ship:

Not_Crashed:

Enemy_Not_Enabled:
	call Add_ix_4
	jr Crash_Checker

Finished_Enemy_Crash:

; ==================================================================================================
; Zombie time handler:
; ==================================================================================================

	

	ld a,(Death_Timer)
	or a
	jr z,Skip_Death_Timer_Handler
	dec a
	ld (Death_Timer),a
	or a
	jp nz,Skip_Death_Timer_Handler


	jp Return_From_Dead

Skip_Death_Timer_Handler:



; ==================================================================================================
; Key input stuff (for moving the ship, checking [Clear] key &c).
; ==================================================================================================


	bcall(_getcsc)
	cp skMul
	jr nz,Not_Multiply
	ld a,(GS_Terrain)
	xor 1
	ld (GS_Terrain),a
	jr Skip_Key_Move

Not_Multiply:
 	
#ifdef SkipLevelKey
	cp skDiv
	jp z,Completed_Level
#endif

	;Check for [CLEAR]

	ld a,KeyRow_5
	out (1),a
	in a,(1)
	cp dkClear
	jp z,Game_Over

	;Contrast:

	ld a,KeyRow_5
	out (1),a
	in a,(1)
	

	cp dKPlus
	jr nz,Not_Plus_Contrast
	ld a,(True_Contrast)
	inc a
	cp 63
	jr z,Skip_Key_Move
	jr Fix_Contrast

Not_Plus_Contrast:
	cp dkMinus
	jr nz,No_Contrast_Change
	ld a,(True_Contrast)
	dec a
	cp 22
	jr z,Skip_Key_Move


Fix_Contrast:
	ld (True_Contrast),a
	push af
	sub $18
	ld (Contrast),a
	pop af
	or $C0
	out ($10),a
	call ionFastCopy
	jr Skip_Key_Move

	
No_Contrast_Change:



	ld a,(Death_Timer)
	or a
	jr nz,Skip_Key_Move

	ld a,KeyRow_5
	out (1),a
	in a,(1)
	bit 3,a
	jr z,Skip_Key_Move


	ld a,KeyRow_Pad
	out (1),a
	in a,(1)
	ld b,a

	ld c,1

	ld a,(Speed_Active)
	or a
	jr z,Not_Speed

	ld c,2
	dec a
	ld (Speed_Active),a
Not_Speed:

Speed_So_Move_Again:
	;Check the movement keys:
	bit 0,b
	call z,Move_Down
	bit 1,b
	call z,Move_Left
	bit 2,b
	call z,Move_Right
	bit 3,b
	call z,Move_Up

	dec c
	ld a,c
	or a
	jr nz,Speed_So_Move_Again

Skip_Key_Move:

	ld a,(Death_Timer)
	or a
	jr nz,Not_2nd
	;Check for 2nd:
	ld a,KeyRow_Top
	out (1),a
	in a,(1)
	bit 5,a
	jr nz,Not_2nd
	ld a,(Game_Type)
	or a
	jr z,Not_2nd
	ld a,1
	ld (Fired),a
Not_2nd:

	bcall(_getcsc)
	cp sk1
	jr nz,Not_1

	ld a,0
	call Start_Powerup

Not_1:



; ==================================================================================================
; Check whether to fire a powerup:
; ==================================================================================================

	ld a,(Death_Timer)
	or a
	jp nz,No_Fire_Powerup

	ld a,(Num_Powerups)
	or a
	jp z,No_Fire_Powerup


	ld a,(Game_Type)
	or a
	jr z,No_Fire_Powerup

	ld a,KeyRow_Top
	out (1),a
	in a,(1)
	bit 6,a
	jr nz,Not_Mode

	ld a,1
	ld (Mode_Down),a
	jr No_Fire_Powerup


	;Whee Fire a powerup

Not_Mode:
	ld a,(Mode_Down)
	or a
	jr z,Mode_Not_Pressed

;fire the powerup:

	ld a,(Powerup_Type)
	cp 1
	jr z,Fire_Shield
	cp 2
	jr z,Fire_Laser
	cp 3
	jr z,Freeze_Time
	cp 4
	jr z,Self_Destruct
	cp 5
	jr z,Start_Speed


Fire_EMP:
	ld a,(Ship_Y)
	ld (EMP_Pos),a
	jr Fired_Powerup


Fire_Shield:
	ld a,100
	ld (Shield_Time),a
	jr Fired_Powerup

Fire_Laser:
	ld a,30
	ld (Laser_Running),a
	jr Fired_Powerup

Freeze_Time:
	ld a,100
	ld (Slow_Running),a
	jr Fired_Powerup

Self_Destruct:
	ld a,20
	ld (Kamikaze_Active),a
	jr Fired_Powerup

Start_Speed:
	ld a,100
	ld (Speed_Active),a

Fired_Powerup:
	ld hl,Num_Powerups
	dec (hl)


Mode_Not_Pressed:

	xor a
	ld (Mode_Down),a
No_Fire_Powerup:


	ld a,KeyRow_Top
	out (1),a
	in a,(1)
	cp dkDel
	call z,Pause
	jp Game_Loop
Game_Over:

	call StartPause

	;Whee :)

	call Init_Grey

	ld hl,i_Game_Over
	ld de,PlotsScreen+288
	ld bc,12*15
	ldir

	ld hl,i_Game_Over
	ld de,SavesScreen+288
	ld bc,12*15
	ldir

Game_Over_Loop:
	call SwapBuffers
	call ionFastCopy

	call CheckPause
	jr nz,Game_Over_Loop
	jp CheckHighScores


; ==================================================================================================
; Quit: Deletes the page file and RETs. Nice. ONLY jump here with the stack preserved!
; ==================================================================================================

Quit:
	call Delete_Page_File
	ret


; ==================================================================================================
; Wahey! You've completed the level!
; ==================================================================================================
Completed_Level:

	call StartPause
	call Init_Grey
	ld hl,Zone_Cleared
	ld de,PlotsScreen+288
	ld bc,12*13
	call RLE

	ld hl,Zone_Cleared
	ld de,SavesScreen+288
	ld bc,12*13
	call RLE

ZoneClearedLoop:
	call SwapBuffers
	call ionFastCopy

	call CheckPause
	jr nz,ZoneClearedLoop
	
	ld hl,Level_Num
	inc (hl)
	ld a,(hl)
	cp NumLevels
	
	jp nz,Start_New_Level

	;Oh dear... are we in extended mode?
	ld a,(Game_Type)
	or a
	jp z,Start_New_Level	;Yep, no "game completed" for you!


; ==================================================================================================
; Wahey^2! You've completed the GAME!
; ==================================================================================================

	;OK. SO, what happens now?

	call Fireworks		;Ooh! Aah!

; ==================================================================================================
; Check High Scores:
; ==================================================================================================

CheckHighScores:

	bcall(_getcsc)
	ld hl,Score
	ld de,High_Score_3
	call CompareScore
	cp 1
	jp nz,NotNewHiScore

	;New high score!



	bcall(_getcsc)
	ld a,' '
	ld hl,EnterInit
	ld bc,3
	bcall(_memset)

	ld hl,EnterInit
	ld (Reg_16_1),hl

Redraw_Score_Enter:

	ld a,$FF
	ld hl,PlotsScreen
	ld bc,768
	bcall(_memset)

	ld hl,NewHighScore
	ld de,PlotsScreen+(12*11)
	ld bc,19*12
	call RLE

	set textInverse, (IY + textFlags)
	set textWrite, (IY + sGrFlags)
#ifndef TI83I
	set fracDrawLFont, (IY + fontFlags)
#endif

#ifndef TI83I
	ld hl,(40*256)+38
#else
	ld hl,(40*256)+42
#endif
	ld (penCol),hl

	ld hl,EnterInit
	ld a,3
Still_Drawing_Init:
	push af
	ld a,(hl)
	inc hl

#ifdef TI83I
	cp ' '
	jr nz,Just_one_Char
	push af
	push af
	push af
	bcall(_vputmap)
	pop af
	bcall(_vputmap)
	pop af
	bcall(_vputmap)
	pop af
Just_one_Char:
#endif

	bcall(_vputmap)
	pop af
	dec a
	or a
	jr nz,Still_Drawing_Init

	;Draw the cursor:

	ld hl,(Reg_16_1)
	ld de,EnterInit
	xor a
	or a
	sbc hl,de
	ld a,l
	
#ifndef TI83I
	;a=a*6
	add a,a
	ld b,a
	add a,a
	add a,b
	add a,38
#else
	;a=a*4
	add a,a
	add a,a
	add a,42
#endif

	ld l,48
	ld b,1
	ld ix,Score_Enter
	call ionPutSprite

	call ionFastCopy


	res textInverse, (IY + textFlags)
	res textWrite, (IY + sGrFlags)

#ifndef TI83I
	res fracDrawLFont, (IY + fontFlags)
#endif

GetLetterLoop:
	call GetLetter
	or a
	jr z,GetLetterLoop

	cp sk2nd
	jr z,Entered_Name

	cp skLeft
	jr nz, NotShuntLeft

	ld hl,(Reg_16_1)
	ld de,EnterInit-1
	dec hl
	bcall(_cphlde)
	jp z,Redraw_Score_Enter
	ld (Reg_16_1),hl
	jp Redraw_Score_Enter

NotShuntLeft:

	cp skRight
	jr nz,NotShuntRight

	ld hl,(Reg_16_1)
	ld de,EnterInit+3
	inc hl
	bcall(_cphlde)
	jp z,Redraw_Score_Enter
	ld (Reg_16_1),hl
	jp Redraw_Score_Enter

NotShuntRight:

	ld hl,(Reg_16_1)
	ld (hl),a
	inc hl
	ld de,EnterInit+3
	bcall(_cphlde)
	jr z,OutOfChars
	ld (Reg_16_1),hl

OutOfChars:
	jp Redraw_Score_Enter

Entered_Name:

	;Add letters to score:

	ld hl,EnterInit
	ld de,Score+6
	ld bc,3
	ldir


	;Copy old scores:
	ld hl,High_Score_1
	ld de,PlotsScreen
	ld bc,9*3
	ldir


	;Now, which score shall we load into?
	ld hl,Score
	ld de,High_Score_1
	call CompareScore
	cp 1
	jr z,Is_Hi1

	ld hl,Score
	ld de,High_Score_2
	call CompareScore
	cp 1
	jr z,Is_Hi2

	;You are third... not a bad effort, but could do with some work :)

	ld hl,Score
	ld de,High_Score_3
	ld bc,9
	ldir

	jr Done_Score


Is_Hi1:
	;OK! We have the super-mega-top score!
	ld hl,PlotsScreen
	ld de,High_Score_2
	ld bc,9*2
	ldir
	ld hl,Score
	ld de,High_Score_1
	ld bc,9
	ldir
	jr Done_Score

Is_Hi2:
	;OK! We have the middle score!
	ld hl,PlotsScreen+9
	ld de,High_Score_3
	ld bc,9
	ldir

	ld hl,Score
	ld de,High_Score_2
	ld bc,9
	ldir
	jr Done_Score

Done_Score:

	;Now we have done that, copy the temp high score table back.

	ld de,Classic_Scores
	ld bc,27
	ld hl,High_Score_1
	ld a,(Game_Type)
	or a
	jr z,Is_Classic_Scores_2
	ld de,Extended_Scores
Is_Classic_Scores_2:
	ldir

NotNewHiScore:

	call DisplayScores
	call Wait_2nd
	jp MainMenu_Start



#ifdef TI83I

;_memset: not the most efficient, but seems to work the most fully like the TI-83 Plus version.
;More efficient versions may cause crashes... this one seems to be fine.

_MemSet:
	push hl
	pop de
_MemSet_Loop:
	ld (de),a
	inc de
	dec bc
	ld h,a
	ld a,b
	or c
	ret z
	ld a,h
	jr _MemSet_Loop
	ret

#endif


#define PUT_CLIPPED_MASKED_SPRITE		;"Switch on" Clipped-Masked sprite support from within the SPRITE.INC file.

;CODE:

#include "general.inc"		;general routines.
#include "drawback.inc"		;background drawing code.
#include "pagefile.inc"		;pagefile creation/deletion.
#include "levelman.inc"		;level decompression &c
#include "sprite.inc"		;sprite-drawing code.
#include "ship.inc"		;ship moving stuff.
#include "vars.inc"		;game-wide variables.
#include "score.inc"		;score handling and drawing
#include "paths.inc"		;Paths for the enemies
#include "attacks.inc"		;Attack formations file
#include "intro.inc"		;Flaming text intro
#include "explode.inc"		;Explosions!
#include "hiscore.inc"		;High score stuff.
#include "firework.inc"		;Firework effects for "end of game".
#include "type.inc"		;Typing code. (No, not typewriting monkeys).
#include "powerups.inc"		;powerup sprites


;DATA:
#include "terrain.inc"		;background sprites.
#include "grfx.inc"		;a selection of graphics.
#include "levels.inc"		;level files
#include "chunks.inc"		;level chunks
#include "tackons.inc"		;start and end of level blocks
#include "sprites.inc"		;sprites for ships/enemies/explosions &c


.end
END
